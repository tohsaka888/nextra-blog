# 处理数据

## 简单变量

程序必须记录 3 个基本属性:

- 信息要存储在哪里
- 要存储什么值
- 存储何种类型的信息

在下面这个例子中：

```cpp
int braincount;
braincount = 5;
```

这些语句告诉程序，它正在存储整数，并使用名称`braincount`来表
示该整数的值（这里为 5）。实际上，程序将找到一块能够存储整数的
内存，将该内存单元标记为`braincount`，并将 5 复制到该内存单元中；然
后，可在程序中使用`braincount`来访问该内存单元。这些语句没有告
诉您，这个值将存储在内存的什么位置，但程序确实记录了这种信息。
实际上，可以使用`&`运算符来检索`braincount`的内存地址。下一章介绍另
一种标识数据的方法（使用指针）时，将介绍这个运算符。

### 变量名

C++提倡使用有一定含义的变量名。如果变量表示差旅费，应将其
命名为`cost_of_trip`或`costOfTrip`，而不要将其命名为`x`或`cot`。必须遵循几
种简单的 C++命名规则。

- 在名称中只能使用字母字符、数字和下划线（`_`）。
- 名称的第一个字符不能是数字。
- 区分大写字符与小写字符。
- 不能将 C++关键字用作名称。
- 以**两个下划线**或**下划线和大写字母**打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。
- C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。

> 倒数第二点与前面几点有些不同，因为使用像`_time_stop`或`_Donut`
> 这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话
> 说，不知道结果将是什么。不出现编译器错误的原因是，这样的名称不
> 是非法的，但要留给实现使用。全局名称指的是名称被声明的位置，这
> 将在第 4 章讨论。

如果想用两个或更多的单词组成一个名称，通常的做法是用下划线
字符将单词分开，如`my_onions`；或者从第二个单词开始将每个单词的
第一个字母大写，如`myEyeTooth`。（C 程序员倾向于按 C 语言的方式使
用下划线，而 Pascal 程序员喜欢采用大写方式。）这两种形式都很容易
将单词区分开，如`carDrip`和`cardRip`或`boat_sport`和`boats_port`。

### 整型

整数就是没有小数部分的数字。整数有很多，不可能用有限的计算机内存来表示所有的整数。因此，语言只能表示所有整数的一个子集。有些语言只提供一种整型（一种类型满足所有要求！），而 C++则提供好几种，这样便能够根据程序的具体要求选择最合适的整型。

不同 C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。

另外，有的类型（符号类型）可表示正值和负值，而有的类型（无符号类型）不能表示负值。术语宽度
（width）用于描述存储整数时使用的内存量。使用的内存越多，则越宽。

C++的基本整型（按宽度递增的顺序排列）分别是`char`、`short`、`int`、`long`和`C++11`新增的`long long`，其中每种类型都有符号版本和无符
号版本，因此总共有 10 种类型可供选择。

### short/int/long/long long

C++的`short`、`int`、`long`和`long long`类型通过使用不同数目的位来存储值，最多能够表示 4 种不同的整数宽度。

C++提供了一种灵活的标准，它确保了最小长度（从 C 语言借鉴而来），如下所示：

- `short`至少 16 位
- `int`至少和`short`一样长
- `long`至少 32 位，且至少和`int`一样长
- `long long`至少 64 位，且至少和`long`一样长

这 4 种类型（`int`、`short`、`long`和`long long`）都是符号类型，这意味着
每种类型的取值范围中，负值和正值几乎相同。例如，16 位的`int`的取值范围为-32768 到+32767。

> `int`通常占操作系统的位数，比如 16 位操作系统中，`int`占 16 位，2 个字节，
> 在 32 位操作系统中，`int`占 32 位，4 个字节，在 64 位操作系统中`int`占 64 位，8 个字节

要知道系统中整数的最大长度，可以在程序中使用 C++工具来检查
类型的长度。首先，`sizeof`运算符返回类型或变量的长度，单位为字节
（运算符是内置的语言元素，对一个或多个数据进行运算，并生成一个
值。例如，加号运算符+将两个值相加）。前面说过，“字节”的含义依
赖于实现，因此在一个系统中，两字节的 int 可能是 16 位，而在另一个系
统中可能是 32 位。

```cpp copy filename="limits.cpp"
// limits.cpp -- some interger limits
#include <iostream>
#include <climits>

int main()
{
  using namespace std;
  int n_int = INT_MAX;      // initialize n_int to max int value
  short n_short = SHRT_MAX; // symbols defined in climits file
  long n_long = LONG_MAX;
  long long n_llong = LLONG_MAX;

  // sizeof operator yields size of type or of variable
  cout << "int is " << sizeof(int) << " bytes." << endl;
  cout << "short is " << sizeof(short) << " bytes." << endl;
  cout << "long is " << sizeof(long) << " bytes." << endl;
  cout << "long long is " << sizeof(long long) << " bytes." << endl;
  cout << endl;

  cout << "Maximum int values:" << endl;
  cout << "int: " << n_int << endl;
  cout << "short: " << n_short << endl;
  cout << "long: " << n_long << endl;
  cout << "long long is " << n_llong << endl;

  cout << "Minimum int value = " << INT_MIN << endl;
  cout << "Bits per byte = " << CHAR_BIT << endl;
}
```

下面是输出结果：

```bash
int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum int values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long is 9223372036854775807
Minimum int value = -2147483648
Bits per byte = 8
```

`sizeof`运算符指出，在使用 8 位字节的系统中，int 的长度为 4 个字
节。。可对类型名或变量名使用 sizeof 运算符。对类型名（如 int）使用
sizeof 运算符时，应将名称放在括号中；但对变量名（如 n_short）使用
该运算符，括号是可选的:

```cpp
cout << "int is " << sizeof(int) << " bytes." << endl;
cout << "short is " << sizeof n_short << " bytes." << endl;
```

#### C++11 初始化方式

C++11 还有一种特殊的初始化方式，这种方式用于数组和结构，但在 C++98
中，也可用于单值变量：

```cpp
int hamburgers = { 24 };
```

将大括号初始化器用于单值变量的情形还不多，但 C++11 标准使得
这种情形更多了。首先，采用这种方式时，可以使用等号（`=`），也可
以不使用：

```cpp
int emus{7}; // 7
int rheas = {12}; // 12
```

其次，大括号内可以不包含任何东西。在这种情况下，变量将被初
始化为零：

```cpp
int rocs = {}; // 0
int psychics{}; // 0
```

第三，这有助于更好地防范类型转换错误，这个主题将在本章末尾讨论。

### 无符号类型

前面介绍的 4 种整型都有一种不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值。例如，如果`short`表示的范围为
−32768 到+32767($-2^{15} \sim 2^{15}$)，则无符号版本的表示范围为 0-65535($0 \sim 2^{16}$)。

当然，仅当数值不会为负时才应使用无符号类型，如人口、粒数等。要创建无符号版本的基本整型，只需使用关键字`unsigned`来修改声明即可：

```cpp
unsigned short change; // unsigned short type
unsigned int revert; // unsigned int type
unsigned quarterback; // alse unsigned int
unsigned long gone; // unsigned long type
unsigned long long lang_lang; // unsigned long long type
```

import { Callout } from "nextra-theme-docs";

<Callout type="info">注意，`unsigned`本身是`unsigned int`的缩写。</Callout>

如下演示了如何使用无符号类型，并说明了程序试图超越整型的限制时将产生的后果。最后，再看一看预处理器语句`#define`。

```cpp copy filename="exceed.cpp"
// exceed.cpp -- exceeding some integer limits
#include <iostream>
#include <climits>
#define ZERO 0

int main()
{
  using namespace std;
  short sam = SHRT_MAX;     // initialize a variable to max value
  unsigned short sue = sam; // okay if variable sam already defined

  cout << "Sam has " << sam << " dollars and Sue has " << sue;
  cout << "dollars deposited." << endl
       << "Add $1 to each account." << endl
       << "Now ";
  sam += 1;
  sue += 1;
  cout << "Sam has " << sam << " dollars and Sue has " << sue;
  cout << " dollars deposited.\nPoor Sam!" << endl;
  sam = ZERO;
  sue = ZERO;
  cout << "Sam has " << sam << " dollars and Sue has " << sue;
  cout << " dollars deposited." << endl;
  cout << "Take $1 from each account." << endl
       << "Now ";
  sam -= 1;
  sue -= 1;
  cout << "Sam has " << sam << " dollars and Sue has " << sue;
  cout << " dollars deposited." << endl
       << "Lucky Sue!" << endl;
}
```

下面是该程序的输出：

```bash
Sam has 32767 dollars and Sue has 32767dollars deposited.
Add $1 to each account.
Now Sam has -32768 dollars and Sue has 32768 dollars deposited.
Poor Sam!
Sam has 0 dollars and Sue has 0 dollars deposited.
Take $1 from each account.
Now Sam has -1 dollars and Sue has 65535 dollars deposited.
Lucky Sue!
```

该程序将一个`short`变量（`sam`）和一个`unsigned short`变量（`sue`）分
别设置为最大的`short`值，在我们的系统上，是`32767`。然后，将这些变
量的值都加 1。这对于`sue`来说没有什么问题，因为新值仍比无符号整数
的最大值小得多；但`sam`的值从`32767`变成了`−32768`！同样，对于`sam`，
将其设置为 0 并减去 1，也不会有问题；但对于无符号变量`sue`，将其设
置为 0 并减去后，它变成了`65535`。可以看出，这些整型变量的行为就像
里程表。如果超越了限制，其值将为范围另一端的取值（参见图 3.1）。C++确保了无符号类型的这种行为；
但 C++并不保证符号整型超越限制（上溢和下溢）时不出错。

![img](https://files.catbox.moe/eqcu47.png)

### 选择整型类型

C++提供了大量的整型，应使用哪种类型呢？通常，`int`被设置为对
目标计算机而言**最为“自然”的长度**。自然长度（_natural size_）指的是计
算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其他类型，则应使用`int`。

现在来看看可能使用其他类型的原因。如果变量表示的值不可能为负，如文档中的字数，则可以使用无符号类型，这样变量可以表示更大
的值。

如果知道变量可能表示的整数值大于 16 位整数的最大可能值，则使用`long`。即使系统上`int`为 32 位，也应这样做。这样，将程序移植到 16 位
系统时，就不会突然无法正常工作。如果要存储的值超过 20 亿，可使用`long long`。

![img](https://files.catbox.moe/eh8f9t.png)

如果`short`比`int`小，则使用`short`可以节省内存。通常，仅当有大型整
型数组时，才有必要使用`short`。（数组是一种数据结构，在内存中连续
存储同类型的多个值。）如果节省内存很重要，则应使用`short`而不是使
用`int`，即使它们的长度是一样的。例如，假设要将程序从`int`为 16 位的系
统移到`int`为`32位`的系统，则用于存储`int`数组的内存量将加倍，但`short`数
组不受影响。请记住，节省一点就是赢得一点。

<Callout type="info"> 如果只需要一个字节，可使用char，这将稍后介绍。 </Callout>

### 整型字面值

整型字面值（常量）是显式地书写的常量，如 212 或 1776。与 C 相同，C++能够以三种不同的计数方式来书写整数：基数为 10、基数为
8（老式 UNIX 版本）和基数为 16（硬件黑客的最爱）。这里将介绍 C++表示法。C++使用前一（两）位来标识
数字常量的基数。如果第一位为 1 ～ 9，则基数为 10（十进制）；因此 93 是以 10 为基数的。如果第一位是 0，第二位为 1 ～ 7，则基数为 8（八进
制）；因此 042 的基数是 8，它相当于十进制数 34。如果前两位为 0x 或 0X，则基数为 16（十六进制）；因此`0x42`为十六进制数，相当于十进
制数 66。对于十六进制数，字符`a～f`和`A～F`表示了十六进制位，对应于`10～15`。`0xF`为 15，`0xA5`为 165（10 个 16 加 5 个 1）。

```cpp copy filename="hexoct1.cpp"
// hexoct1.cpp -- shows hex and octal literals
#include <iostream>
int main()
{
  using namespace std;
  int chest = 42;   // decimal integer literal
  int waist = 0x42; // hexadecimal integer literal
  int inseam = 042; // octal integer literal

  cout << "Monsieur cuts a striking figure!\n";
  cout << "chest = " << chest << " (42 in decimal)\n";
  cout << "waist = " << waist << " (42 in hex)\n";
  cout << "inseam = " << inseam << " (42 in octal)\n";
}
```

在默认情况下，cout 以十进制格式显示整数，而不管这些整数在程
序中是如何书写的，如下面的输出所示：

```bash
Monsieur cuts a striking figure!
chest = 42 (42 in decimal)
waist = 66 (42 in hex)
inseam = 34 (42 in octal)
```

<Callout>

记住，这些表示方法仅仅是为了表达上的方便。例如，如果 `CGA` 视频内存段为十六进制 `B000`，则不必在程序中使用之前将它转换为十进制
数`45056`，而只需使用`0xB000`即可。但是，不管把值书写为`10`、`012`还是`0xA`，都将以相同的方式存储在计算机中—被存储为二进制数（以 2 为基数）。

</Callout>

顺便说一句，如果要以十六进制或八进制方式显示值，则可以使用
`cout`的一些特殊特性。前面指出过，头文件`iostream`提供了控制符`endl`，
用于指示`cout`重起一行。同样，它还提供了控制符`dec`、`hex`和`oct`，分别
用于指示`cout`以十进制、十六进制和八进制格式显示整数。如下程序使用了`hex`和`oct`以上述三种格式显示十进制值 42。默认格式为十进制，
在修改格式之前，原来的格式将一直有效。

```cpp copy filename="hexoct2.cpp"
// hexoct1.cpp -- shows hex and octal literals
#include <iostream>
int main()
{
  using namespace std;
  int chest = 42;  // decimal integer literal
  int waist = 42;  // hexadecimal integer literal
  int inseam = 42; // octal integer literal

  cout << "Monsieur cuts a striking figure!\n";
  cout << "chest = " << chest << " (42 in decimal)\n";
  cout << hex;
  cout << "waist = " << waist << " (42 in hex)\n";
  cout << oct;
  cout << "inseam = " << inseam << " (42 in octal)\n";
}
```

下面是运行该程序时得到的输出：

```bash
Monsieur cuts a striking figure!
chest = 42 (42 in decimal)
waist = 2a (42 in hex)
inseam = 52 (42 in octal)
```

诸如`cout<<hex`;等代码不会在屏幕上显示任何内容，而只是修改`cout`显示整数的方式。因此，控制符`hex`实际上是一条消息，告诉`cout`采
取何种行为。另外，由于标识符`hex`位于名称空间`std`中，而程序使用了该名称空间，因此不能将`hex`用作变量名。然而，如果省略编译指令
`using`，而使用`std::cout`、`std::endl`、`std::hex`和`std::oct`，则可以将`hex`用作变量名。

### C++如何确定常量的类型

程序的声明将特定的整型变量的类型告诉了 C++编译器，但编译器是如何知道常量的类型呢？

```cpp
cout << "Year = " << 1492 << endl;
```

程序将把`1492`存储为`int`、`long`还是其他整型呢？答案是，除非有理由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太
大，不能存储为`int`），否则 C++将整型常量存储为`int`类型。

首先来看看后缀。后缀是放在数字常量后面的字母，用于表示类
型。整数后面的`l`或`L`后缀表示该整数为`long`常量，`u`或`U`后缀表示
`unsigned int`常量，`ul`（可以采用任何一种顺序，大写小写均可）表示
`unsigned long`常量（由于小写`l`看上去像`1`，因此应使用大写`L`作后缀）。
例如，在`int`为 16 位、`long`为 32 位的系统上，数字`22022`被存储为`int`，占
16 位，数字`22022L`被存储为`long`，占 32 位。同样，`22022LU`和`22022UL`
都被存储为`unsigned long`。C++11 提供了用于表示类型`long long`的后缀`ll`
和`LL`，还提供了用于表示类型`unsigned long long`的后缀`ull、Ull、uLL和
ULL`。

### char 类型：字符和小整数

下面介绍最后一种整型：`char`类型。顾名思义，`char`类型是专为存储字符（如字母和数字）而设计的。现在，存储数字对于计算机来说算
不了什么，但存储字母则是另一回事。编程语言通过使用字母的数值编码解决了这个问题。因此，`char`类型是另一种整型。它足够长，能够表
示目标计算机系统中的所有基本符号—所有的字母、数字、标点符号等。实际上，很多系统支持的字符都不超过 128 个，因此用一个字节就
可以表示所有的符号。因此，虽然`char`最常被用来处理字符，但也可以将它用做比`short`更小的整型。

```cpp copy filename="chartype.cpp"
// chartype.cpp -- the chart type
#include <iostream>
int main()
{
  using namespace std;
  char ch; // declear a char variable

  cout << "Enter a character: " << endl;
  cin >> ch;
  cout << "Hola! ";
  cout << "Thank you for the " << ch << " character." << endl;
}
```

同样，`\n`在 C++中表示换行符。下面是该程序的输出：

```bash
Enter a character:
M
Hola! Thank you for the M character.
```

有趣的是，程序中输入的是`M`，而不是对应的字符编码`77`。另外，程序将打印`M`，而不是`77`。通过查看内存可以知道，`77`是存储在变量`ch`
中的值。这种神奇的力量不是来自`char`类型，而是来自`cin`和`cout`，这些工具为您完成了转换工作。输入时，`cin`将键盘输入的`M`转换为`77`；输出
时，`cout`将值`77`转换为所显示的字符`M`；`cin`和`cout`的行为都是由变量类
型引导的。如果将`77`存储在`int`变量中，则`cout`将把它显示为`77`（也就是
说，cout 显示两个字符 7）。

```cpp copy filename="morechar.cpp"
// morechar.cpp -- the char type and int type contrast
#include <iostream>
int main()
{
  using namespace std;
  char ch = 'M'; // assign ASCII code for M to ch
  int i = ch;    // store same code in an int
  cout << "The ASCII code for " << ch << " is " << i << endl;

  cout << "Add one to the character code: " << endl;
  ch += 1; // change character code in ch
  i = ch;  // save new character code in i
  cout << "The ASCII code for " << ch << " is " << i << endl;

  // using the cout.put() member function to display a character
  cout << "Displaying char ch using cout.put(ch): ";
  cout.put(ch);

  // using the cout.put to display a char constant
  cout.put('!');

  cout << endl
       << "Done!" << endl;
}
```

程序输出如下：

```bash
The ASCII code for M is 77
Add one to the character code:
The ASCII code for N is 78
Displaying char ch using cout.put(ch): N!
Done!
```

‘M’表示字符 M 的数值编码，因此将`char`变量`ch`初始化为‘M’，将把 c 设置为`77`。然后，程序将同样的值赋给`int`变量`i`，
这样`ch`和`i`的值都是 77。接下来，`cout`把`ch`显示为`M`，而把`i`显示为`77`。如前所述，值的类型将引导`cout`选择如何显示值—这是智能对象的另一个
例子。

由于`ch`实际上是一个整数，因此可以对它使用整数操作，如加 1，这将把`ch`的值变为`78`。然后，程序将`i`重新设置为新的值（也可以将 i 加
1）。`cout`再次将这个值的`char`版本显示为字符，将`int`版本显示为数字。

即使通过键盘输入的数字也被视为字符。请看下面的代码：

```cpp
char ch;
cin >> ch;
```

如果您输入`5`并按回车键，上述代码将读取字符“5”，并将其对应的字符编码（`ASCII`编码`53`）存储到变量`ch`中。请看下面的代码：

```cpp
int n;
cin >> n;
```

如果您也输入`5`并按回车键，上述代码将读取字符“5”，将其转换为相应的数字值`5`，并存储到变量`n`中。

#### 成员函数`cout.put()`

`cout.put()`到底是什么东西？其名称中为何有一个句点？函数`cout.put()`是一个重要的 C++ **OOP 概念—成员函数—**的第一个例子。类
定义了如何表示和控制数据。成员函数归类所有，描述了操纵类数据的方法。例如类`ostream`有一个`put()`成员函数，用来输出字符。只能通过
类的特定对象（例如这里的`cout`对象）来使用成员函数。要通过对象（如`cout`）使用成员函数，必须用**句点将对象名和函数名称（`put()`）连
接起来**。句点被称为成员运算符。`cout.put()`的意思是，通过类对象`cout`来使用函数`put()`。

#### char 字面值

在 C++中，书写字符常量的方式有多种。对于常规字符（如字母、标点符号和数字），最简单的方法是将字符用单引号括起。这种表示法
代表的是字符的数值编码。例如，`ASCII`系统中的对应情况如下：

- 'A'为 65，即字符 A 的 ASCII 码；
- 'a'为 97，即字符 a 的 ASCII 码；
- '5'为 53，即数字 5 的 ASCII 码；
- ' '为 32，即空格字符的 ASCII 码；
- '!'为 33，即惊叹号的 ASCII 码。

有些字符不能直接通过键盘输入到程序中。例如，按回车键并不能使字符串包含一个换行符；相反，程序编辑器将把这种键击解释为在源
代码中开始新的一行。其他一些字符也无法从键盘输入，因为 C++语言赋予了它们特殊的含义。例如，双引号字符用来分隔字符串字面值，因
此不能把双引号放在字符串字面值中。对于这些字符，C++提供了一种特殊的表示方法—转义序列，如表 3.2 所示。例如，`\a`表示振铃字符，它
可以使终端扬声器振铃。转义序列`\n`表示换行符，`\”`将双引号作为常规字符，而不是字符串分隔符。可以在字符串或字符常量中使用这些表示
法，如下例所示：

```cpp
char alarm = '\a';
cout << alarm << "Don't do that again." << endl;
cout << "Ben \"Buggsie\" Hacker\nwas here!\n";
```

如下程序演示了一些转义序列。它使用振铃字符来提请注意，使用换行符使光标前进，使用退格字符使光标向左退一格。

```cpp copy filename="bondini.cpp"
// bondini.cpp -- using escape sequences
#include <iostream>
int main()
{
  using namespace std;
  cout << "\aOperation \"HyperHype\" is now activated.\n";
  cout << "Enter your agent code: ________\b\b\b\b\b\b\b\b";
  long code;
  cin >> code;
  cout << "\aYou entered " << code << "...\n";
  cout << "\aCode verified!Proceed with Plan23!\n";
}
```

运行程序时，将显示以下文本：

```bash
Operation "HyperHype" is now activated.
Enter your agent code: ________
```

打印下划线字符后，程序使用退格字符将光标退到第一个下划线处。读者可以输入自己的密码，并继续。下面是完整的运行情况：

```bash
Operation "HyperHype" is now activated.
Enter your agent code: 15613226
You entered 15613226...
Code verified!Proceed with Plan23!
```

#### 通用字符名(Unicode)

通用字符名的用法类似于转义序列。通用字符名可以以`\u`或`\U`打
头。`\u`后面是 8 个十六进制位，`\U`后面则是 16 个十六进制位。这些位表
示的是字符的`ISO 10646`码点（`ISO 10646`是一种正在制定的国际标准，
为大量的字符提供了数值编码，请参见本章后面的“Unicode 和 ISO
10646”）。

#### signed char 和 unsigned char

与`int`不同的是，`char`在默认情况下既不是没有符号，也不是有符号。是否有符号由`C++`实现决定，这样编译器开发人员可以最大限度地
将这种类型与硬件属性匹配起来。如果`char`有某种特定的行为对您来说非常重要，则可以显式地将类型设置为`signed char` 或`unsigned char`：

```cpp
char fodo;
unsigned char bar;
signed char snark;
```

如果将`char`用作**数值类型**，则`unsigned char`和`signed char`之间的差异
将非常重要。`unsigned char`类型的表示范围通常为 `0 ～ 255`，而`signed char`
的表示范围为 `−128 ~ 127`。例如，假设要使用一个`char`变量来存储像 200
这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。但
使用`unsigned char`可以在任何系统上达到这种目的。另一方面，如果使
用`char`变量来存储标准`ASCII`字符，则`char`有没有符号都没关系，在这种
情况下，可以使用`char`。

#### wcha_t

程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种。首先，如果大型字符
集是实现的基本字符集，则编译器厂商可以将`char`定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和
一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型`wchar_t`（宽字符类型）可以表示扩展字符集。`wchar_t`类型是一种整数
类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。
对底层类型的选择取决于实现，因此在一个系统中，它可能是`unsigned short`，而在另一个系统中，则可能是`int`。

`cin`和`cout`将输入和输出看作是`char`流，因此不适于用来处理`wchar_t`
类型。`iostream`头文件的最新版本提供了作用相似的工具—`wcin`和
`wcout`，可用于处理`wchar_t`流。另外，可以通过加上前缀L来指示宽字
符常量和宽字符串。下面的代码将字母P的`wchar_t`版本存储到变量`bob`
中，并显示单词`tall`的`wchar_t`版本：

```cpp
wchar_t bob = L'P'; // a wide-character constant
wcout << L"tall" << endl; // outputing a wide-character string
```

在支持两字节`wchar_t`的系统中，上述代码将把每个字符存储在一个两个字节的内存单元中。本书不使用宽字符类型，但读者应知道有这
种类型，尤其是在进行国际编程或使用`Unicode`或`ISO 10646`时。

#### `char16_t`和`char32_t`





