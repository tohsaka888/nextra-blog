import { Callout } from "nextra-theme-docs";

# 复合类型

## 数组

数组（_array_）是一种数据格式，能够存储多个同类型的值。例如，数组可以存储 60 个`int`类型的值
（这些值表示游戏 5 年来的销售量）、12 个`short`值（这些值表示每个月的天数）或 365 个`float`值
（这些值指出一年中每天在食物方面的开销）。每个值都存储在一个独立的数组元素
中，计算机在内存中依次存储数组的各个元素。

要创建数组，可使用声明语句。数组声明应指出以下三点：

- 存储在每个元素中的值的类型
- 数组名
- 数组中的元素数

声明数组的通用格式如下：

```cpp
typeName arrayName[arraySize];
```

表达式`arraySize`指定元素数目，它必须是整型常数（如 10）或`const`值，也可以是常量表达式（如`8 * sizeof（int）`），
即其中所有的值在编译时都是已知的。具体地说，`arraySize`**不能是变量**，变量的值是在程序运行时设置的。
然而，本章稍后将介绍如何使用`new`运算符来避开这种限制。

![img](https://files.catbox.moe/y8ep7y.png)

```cpp copy filename="arrayone.cpp"
// arrayone.cpp -- small arrays of integers
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int yams[3]; // create array with 3 elements
  yams[0] = 7; // assign value to first element
  yams[1] = 8; // assign value to second element
  yams[2] = 6;

  int yamcosts[3] = {20, 30, 5};
  // NOTES: if your c++ compiler or translator can't initialize
  // this array use static int yamcosts[3] instead of int yamcosts[3]

  cout << "Total yams = ";
  cout << yams[0] + yams[1] + yams[2] << endl;
  cout << "The package with " << yams[1] << " yams costs ";
  cout << yamcosts[1] << " cents per yam.\n";
  int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1] + yams[2] * yamcosts[2];
  cout << "The total yam expense is " << total << " cents.\n"
       << endl;
  cout << "\nSize of yams array = " << sizeof yams << " bytes.\n";
  cout << "Size of one element = " << sizeof yams[0] << " bytes.\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Total yams = 21
The package with 8 yams costs 30 cents per yam.
The total yam expense is 410 cents.


Size of yams array = 12 bytes.
Size of one element = 4 bytes.
```

<Callout type="info">

`sizeof`运算符返回类型或数据对象的长度（单位为字节）。注意，如果将 sizeof 运算符用于数组名，
得到的将是整个数组中的字节数。但如果将`sizeof`用于数组元素，则得到的将是元素的长度（单位为字节）。
这表明`yams`是一个数组，而`yams[1]`只是一个`int`变量。

</Callout>

### 数组的初始化规则

`C++`有几条关于初始化数组的规则，它们限制了初始化的时刻，决定了数组的元素数目与初始化器中值的数目不相同时将发生的情况。
我们来看看这些规则。

只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

```cpp
int cards[4] = { 3, 6, 8, 10 };
int hand[4];
hand[4] = { 5, 6, 7, 8 }; // not allowed
hand = cards; // not allowed
```

然而，可以使用下标分别给数组中的元素赋值。

初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化`hotelTips`的前两个元素：

```cpp
float hotelTips[5] = { 5.0, 2.5 };
```

如果只对数组的一部分进行初始化，则编译器将把其他元素设置为`0`。
因此，将数组中所有的元素都初始化为 0 非常简单—只要显式地将第一个元素初始化为 0，然后让编译器将其他元素都初始化为 0 即可：

```cpp
long totals[500] = { 0 };
```

> 如果初始化为`{1}`而不是`{0}`，则第一个元素被设置为 1，其他元素都被设置为 0。

如果初始化数组时方括号内（`[]`）为空，C++编译器将计算元素个数。例如，对于下面的声明:

```cpp
short things[] = { 1, 5, 3, 8 };
```

编译器将使`things`数组包含 4 个元素。

### 数组初始化方法

C++11 将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化，
但 C++11 中的列表初始化新增了一些功能。

首先，初始化数组时，可省略等号（`=`）：

```cpp
double earnings[4] { 1.24e4, 1.6e4, 1.1e4, 1.7e4 };
```

其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：

```cpp
unsigned int counts[10] = {};
float balances[100] {};
```

第三，列表初始化禁止缩窄转换，这在第 3 章介绍过：

```cpp
long plifs[] = { 25, 92, 3.0 }; // not allowed
char slifs[4] = { 'h', 'i', 1122011, '\0' }; // not allowed
char tlifs[4] = { 'h', 'i', 112, '\0' }; // allowed
```

在上述代码中，第一条语句不能通过编译，因为**将浮点数转换为整型是缩窄操作**，即使浮点数的小数点后面为零。
第二条语句也不能通过编译，因为`1122011`超出了`char`变量的取值范围（这里假设 char 变量的长度为 8 位）。
第三条语句可通过编译，因为虽然 112 是一个`int`值，但它在`char`变量的取值范围内。

C++标准模板库（STL）提供了一种数组替代品—模板类`vector`，而 C++11 新增了模板类 array。
这些替代品比内置复合类型数组更复杂、更灵活，本章将简要地讨论它们，而第 16 章将更详细地讨论它们。

## 字符串

C++处理字符串的方式有两种。第一种来自 C 语言，常被称为 C-风格字符串（_C-style string_）。

C-风格字符串具有一种特殊的性质：以空字符（_null character_）结尾，空字符被写作`\0`，
其`ASCII`码为`0`，用来标记字符串的结尾。例如，请看下面两个声明：

```cpp
char dog[8] = { 'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I' }; // not a string
char cat[8] = { 'f', 'a', 't', 'e', 's', 's', 'a', '\0' }; // a string
```

这两个数组都是`char`数组，但只有第二个数组是字符串。空字符对 C-风格字符串而言至关重要。
例如，C++有很多处理字符串的函数，其中包括`cout`使用的那些函数。它们都逐个地处理字符串中的字符，
**直到到达空字符为止**。如果使用`cout`显示上面的`cat`这样的字符串，则将显示前 7 个字符，发现空字符后停止。
但是，如果使用`cout`显示上面的`dog`数组（它不是字符串），`cout`将打印出数组中的 8 个字母，
**并接着将内存中随后的各个字节解释为要打印的字符**，直到遇到空字符为止。
由于空字符（实际上是被设置为 0 的字节）在内存中很常见，因此这一过程将很快停止。
但尽管如此，还是不应将不是字符串的字符数组当作字符串来处理。

在`cat`数组示例中，将数组初始化为字符串的工作看上去冗长乏味—使用大量单引号，
且必须记住加上空字符。不必担心，有一种更好的、将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串即可，
这种字符串被称为**字符串常量**（_string constant_）或**字符串字面值**（_string literal_），如下所示：

```cpp
char bird[11] = "Mr. Cheeps"; // the \0 is understood
char fish[] = "Bubbles"; // let the compiler count
```

<Callout type="info">

用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。
另外，各种`C++`输入工具通过键盘输入，将字符串读入到`char`数组中时，将自动加上结尾的空字符。

当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。
使用字符串常量初始化字符数组是这样的一种情况，即**让编译器计算元素数目更为安全**。
让数组比字符串长没有什么害处，只是会浪费一些空间而已。
这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

</Callout>

![img](https://files.catbox.moe/06201j.png)

注意，字符串常量（使用双引号）不能与字符常量（使用单引号）互换。
字符常量（如`'S'`）是字符串编码的简写表示。在`ASCII`系统上，`'S'`只是 83 的另一种写法，因此，
下面的语句将`83`赋给`shirt_size`：

```cpp
short size = 'S'; // legal
short shirt_size = "S"; // illegal type mismatch
```

<Callout type="error">

`"S"`不是字符常量，它表示的是两个字符（字符 S 和\0）组成的字符串。
更糟糕的是，`"S"`实际上表示的是**字符串所在的内存地址**。
因此语句试图将一个内存地址赋给`shirt_size`，显然是不合法的。

</Callout>

### 拼接字符串常量

有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。
事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
因此，下面所有的输出语句都是等效的：

```cpp copy
std::cout << "I'd give my right arm to be" " a great violinist.\n";
std::cout << "I'd give my right arm to be a great violinist.\n";
std::cout << "I'd give my right ar" "m to be a great violinist.\n";
```

<Callout type="warning">

注意，拼接时不会在被连接的字符串之间添加空格，
第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑`\0`）后面。
**第一个字符串中的`\0`字符将被第二个字符串的第一个字符取代**。

</Callout>

### 在数组中使用字符串

要将字符串存储到数组中，最常用的方法有两种—将数组初始化为字符串常量、将键盘或文件输入读入到数组中。

```cpp copy filename="string.cpp"
#include <cstring>
#include <iostream>
int main(int argc, char const *argv[])
{
  using namespace std;
  const int Size = 15;
  char name1[Size];
  char name2[Size] = "C++owboy";

  // NOTE: some implementations may require the static keyword
  // to initialize the array name2
  cout << "Howdy! I'm " << name2;
  cout << "! What's your name?\n";
  cin >> name1;

  cout << "Well, " << name1 << ", your name has ";
  cout << strlen(name1) << " letters and is stored\n";
  cout << "in an array of " << sizeof(name1) << " bytes.\n";

  cout << "Your initial is " << name1[0] << ".\n";
  name2[3] = '\0';
  cout << "Here are the fiest 3 characters of my name: ";
  cout << name2 << endl;
  return 0;
}
```

下面是该程序的运行情况：

```bash

Howdy! I'm C++owboy! What's your name?
tohsaka888
Well, tohsaka888, your name has 10 letters and is stored
in an array of 15 bytes.
Your initial is t.
Here are the fiest 3 characters of my name: C++
```

<Callout type="tip">

该程序使用符号常量来指定数组的长度。程序常常有多条语句使用了数组长度。
使用符号常量来表示数组长度后，当需要修改程序以使用不同的数组长度时，
工作将变得更简单—只需在定义符号常量的地方进行修改即可。

</Callout>

![img](https://files.catbox.moe/yy2pch.png)

### 字符串输入

程序`strings.cpp`有一个缺陷，这种缺陷通过精心选择输入被掩盖掉了。
下面的程序，揭示了字符串输入的技巧。

```cpp copy filename="instr1.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "Enter your name:\n";
  cin >> name;
  cout << "Enter your favourite dessert:\n";
  cin >> dessert;
  cout << "I have some delicious " << dessert;
  cout << " for you, " << name << "\n";
  return 0;
}
```

该程序的意图很简单：读取来自键盘的用户名和用户喜欢的甜点，然后显示这些信息。下面是该程序的运行情况：

```bash
Enter your name:
Alistair Dreeb
Enter your favourite dessert:
I have some delicious Dreeb for you, Alistair
```

我们甚至还没有对“输入甜点的提示”作出反应，程序便把它显示出来了，然后立即显示最后一行。

`cin`是如何确定已完成字符串输入呢？由于不能通过键盘输入空字符，因此`cin`需要用别的方法来确定字符串的结尾位置。
`cin`使用**空白（空格、制表符和换行符）来确定字符串的结束位置**，这意味着`cin`在获取字符数组输入时只读取一个单词。
读取该单词后，`cin`将该字符串放到数组中，并自动在结尾添加空字符。

这个例子的实际结果是，`cin`把`Alistair`作为第一个字符串，并将它放到`name`数组中。
这把`Dreeb`留在输入队列中。当`cin`在输入队列中搜索用户喜欢的甜点时，它发现了`Dreeb`，
因此`cin`读取`Dreeb`，并将它放到`dessert`数组中。

![img](https://files.catbox.moe/hwf1n4.png)

另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出来）。
像这个例子一样使用`cin`，确实不能防止将包含 30 个字符的字符串放到 20 个字符的数组中的情况发生。

### 每次读取一行的字符串输入

#### 面向行输出：`getline()`

`getline()`函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
要调用这种方法，可以使用`cin.getline()`。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，
第二个参数是要读取的字符数。如果这个参数为 20，则函数最多读取 19 个字符，余下的空间用于存储自动在结尾处添加的空字符。
`getline()`成员函数在读取指定数目的字符或遇到换行符时停止读取。

例如，假设要使用`getline()`将姓名读入到一个包含 20 个元素的`name`数组中。可以使用这样的函数调用：

```cpp
cin.getline(name, 20);
```

> 这将把一行读入到`name`数组中—如果这行包含的字符不超过 19 个。

```cpp copy filename="instr2.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "Enter your name:\n";
  cin.getline(name, ArSize); // reads through newline
  cout << "Enter your favorite dessert:\n";
  cin.getline(dessert, ArSize); // reads through newline
  cout << "I have some delicious " << dessert;
  cout << " for you, " << name << ".\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Enter your name:
Elon Mask
Enter your favorite dessert:
shit
I have some delicious shit for you, Elon Mask.
```

![img](https://files.catbox.moe/dakuls.png)

#### 面向行的输入：`get()`

`istream`类有另一个名为`get()`的成员函数，该函数有几种变体。其中一种变体的工作方式与`getline()`类似，
它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但`get`并不再读取并丢弃换行符，而是将其留在输入队列中。
假设我们连续两次调用`get()`：

```cpp
cin.get(name, ArSize);
cin.get(dessert, ArSize);
```

由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。
因此`get()`认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，`get()`将不能跨过该换行符。

> 也就是说第二次的`get()`会读取到一个换行符。

幸运的是，`get()`有另一种变体。使用不带任何参数的`cin.get()`调用可读取下一个字符（即使是换行符），
因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：

```cpp
cin.get(name, ArSize);
cin.get();
cin.get(dessert, ArSize);
```

另一种使用`get()`的方式是将两个类成员函数拼接起来（合并），如下所示：

```cpp
cin.get(name, ArSize).get(); // concatenate member functions
```

之所以可以这样做，是由于`cin.get(name, ArSize)`返回一个`cin`对象，该对象随后将被用来调用`get()`函数。
同样，下面的语句将把输入中连续的两行分别读入到数组`name1`和`name2`中，其效果与两次调用`cin.getline()`相同：

```cpp
cin.getline(name1, ArSize).getline(name2, ArSize);
```

### 混合输入字符串和数字

混合输入数字和面向行的字符串会导致问题。

```cpp copy filename="numstr.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  cout << "What year was your house built?\n";
  int year;
  cin >> year;
  cout << "What is its street address?\n";
  char address[80];
  cin.getline(address, 80);
  cout << "Year built: " << year << endl;
  cout << "Address: " << address << endl;
  cout << "Done!\n";
  return 0;
}
```

该程序的运行情况如下：

```bash

What year was your house built?
1966
What is its street address?
Year built: 1966
Address:
Done!
```

用户根本没有输入地址的机会。问题在于，当`cin`读取年份，将回车键生成的换行符留在了输入队列中。
后面的`cin.getline()`看到换行符后，将认为是一个空行，并将一个空字符串赋给`address`数组。
解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，
其中包括使用没有参数的`get()`和使用接受一个`char`参数的`get()`，
如前面的例子所示。可以单独进行调用:

```cpp copy
cin >> years;
cin.get();
```

也可以利用表达式`cin>>year`返回`cin`对象，将调用拼接起来：

```cpp copy
(cin >> year).get();
```

## `String`类简介

要使用`string`类，必须在程序中包含头文件`string`。`string`类位于名称空间`std`中，
因此您必须提供一条`using`编译指令，或者使用`std::string`来引用它。
`string`类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。
下面程序说明了`string`对象与字符数组之间的一些相同点和不同点。

```cpp copy filename="strtype1.cpp"
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr1[20];            // create an empty array
  char charr2[20] = "jaguar"; // create an initialized array
  string str1;                //  create an empty string object
  string str2 = "panther";    // create an initialized string

  cout << "Enter a kind of feline: ";
  cin >> charr1;
  cout << "Enter another kind of feline: ";
  cin >> str1;
  cout << "Here are some felines:\n";
  cout << charr1 << " " << charr2 << " "
       << str1 << " " << str2 << endl;
  cout << "The third letter in " << charr2 << " is " << charr2[2] << endl;
  cout << "The third letter in " << str2 << " is " << str2[2] << endl; // use array notation
  return 0;
}
```

从这个示例可知，在很多方面，使用`string`对象的方式与使用字符数组相同。

- 可以使用 C-风格字符串来初始化`string`对象。
- 可以使用`cin`来将键盘输入存储到`string`对象中。
- 可以使用`cout`来显示`string`对象。
- 可以使用数组表示法来访问存储在`string`对象中的字符。

`string`对象和字符数组之间的主要区别是，可以将`string`对象声明为简单变量，而不是数组：

```cpp
string str1;  // create an empty string object
string str2 = "panther";  // create an initialized string
```

类设计让程序能够自动处理`string`的大小。例如，`str1`的声明创建一个长度为 0 的`string`对象，
但程序将输入读取到`str1`中时，将自动调整`str1`的长度：

```cpp
cin >> str1; // str1 resized to fit input
```

这使得与使用数组相比，使用`string`对象更方便，也更安全。
从理论上说，可以将`char`数组视为一组用于存储一个字符串的`char`存储单元，而`string`类变量是一个表示字符串的实体。

## 字符串初始化

C++11 也允许将列表初始化用于 C-风格字符串和`string`对象:

```cpp
char first_date[] = { "Le Chapon Dodu" };
char second_date[] = { "The Elegant Plate" };
string third_date[] = { "The Bread Bowl" };
string fourth_date[] = { "Hank's Fine Eats" };
```

## 赋值、拼接和附加

使用`string`类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，
但可以将一个`string`对象赋给另一个`string`对象：

```cpp
char charr1[20]; // create an empty array
char charr2[20] = "jaguar"; // create an initialized array
string str1; // create an empty string object
string str2 = "pather"; // create an initialized string
charr1 = charr2; // INVALID, no array assignment
str1 = str2; // INVALID, object assignment ok
```

`string`类简化了字符串合并操作。可以使用运算符`+`将两个`string`对象合并起来，
还可以使用运算符`+=`将字符串附加到`string`对象的末尾。继续前面的代码，您可以这样做：

```cpp
string str3;
str3 = str1 + str2;
str1 += str2;
```

下面的程序演示了这些用法。可以将 C-风格字符串或 `string` 对象与`string` 对象相加，
或将它们附加到 `string` 对象的末尾。

```cpp
#include <iostream>
#include <string>
int main(int argc, char const *argv[])
{
  using namespace std;
  string s1 = "penguin";
  string s2, s3;

  cout << "You can assign one string object to another: s2 = s1\n";
  s2 = s1;
  cout << "s1: " << s1 << ", s2: " << s2 << endl;
  cout << "You can assign a C-style string to a string object.\n";
  cout << "s2 = \"buzzard\"\n";
  s2 = "buzzard";
  cout << "s2: " << s2 << endl;
  cout << "You can concatenate strings: s3 = s1 + s2\n";
  s3 = s1 + s2;
  cout << "s3: " << s3 << endl;
  cout << "You can append strings.\n";
  s1 += s2;
  cout << "s1 += s2 yields s1 = " << s1 << endl;
  s2 += " for a day";
  cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;
  return 0;
}
```

转义序列`\"`表示双引号，而不是字符串结尾。该程序的输出如下：

```bash
You can assign one string object to another: s2 = s1
s1: penguin, s2: penguin
You can assign a C-style string to a string object.
s2 = "buzzard"
s2: buzzard
You can concatenate strings: s3 = s1 + s2
s3: penguinbuzzard
You can append strings.
s1 += s2 yields s1 = penguinbuzzard
s2 += " for a day" yields s2 = buzzard for a day
```

### string 类的其他操作

在 C++新增`string`类之前，程序员也需要完成诸如给字符串赋值等工作。
对于 C-风格字符串，程序员使用 C 语言库中的函数来完成这些任务。
头文件`cstring`（以前为`string.h`）提供了这些函数。
例如，可以使用函数`strcpy()`将**字符串复制到字符数组**中，
使用函数`strcat()`将**字符串附加到字符数组末尾**。

```cpp
strcpy(charr1, charr2); // copy charr1 to charr2
strcat(charr1, charr2); // append contents of charr2 to charr1
```

下面的程序对用于`string`对象的技术和用于字符数组的技术进行了比较。

```cpp copy filename="strtype3.cpp"
#include <cstring>
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr1[20];
  char charr2[20] = "jaguar";
  string str1;
  string str2 = "panther";

  // assignment for string objects and character arrays
  str1 = str2;            // copy str2 to str1
  strcpy(charr1, charr2); // copy charr2 to charr1

  // appending for string objects and character arrays
  str1 += " paste";
  strcat(charr1, " juice");

  // finding the length of a string object and C-style string
  int len1 = str1.size();
  int len2 = strlen(charr1);

  cout << "The string " << str1 << " contains " << len1 << " characters." << endl;
  cout << "The string " << charr1 << " contains " << len2 << " characters." << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
The string panther paste contains 13 characters.
The string jaguar juice contains 12 characters.
```

处理`string`对象的语法通常比使用 C 字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：

```cpp
str3 = str1 + str2;
```

使用 C-风格字符串时，需要使用的函数如下：

```cpp
strcpy(charr3, charr1);
strcpy(charr3, charr2);
```

另外，使用字符数组时，总是存在**目标数组过小**，无法存储指定信息的危险，如下面的示例所示：

```cpp
char site[10] = "house";
strcat(site, " of pancakes");  // memory problem
```

函数`strcat()`试图将全部 12 个字符复制到数组`site`中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，
但数据被损坏。`string`类具有**自动调整大小**的功能，从而能够避免这种问题发生。
C 函数库确实提供了与`strcat()`和`strcpy()`类似的函数—`strncat()`和`strncpy()`，
它们接受指出目标数组最大允许长度的第三个参数，因此更为安全，但使用它们进一步增加了编写程序的复杂度。

下面是两种确定字符串中字符数的方法：

```cpp
int len1 = str1.size();
int len2 = strlen(charr1);
```

函数`strlen()`是一个常规函数，它接受一个 C-风格字符串作为参数，并返回该字符串包含的字符数。
函数`size()` 的功能基本上与此相同，但句法不同：`str1`不是被用作函数参数，而是位于函数名之前，
它们之间用句点连接。与第 3 章介绍的`put()`方法相同，这种句法表明，`str1`是一个对象，
而`size()` 是一个类方法。方法是一个函数，只能通过其所属类的对象进行调用。
在这里，`str1`是一个`string`对象，而`size()`是`string`类的一个方法。
总之，C 函数使用参数来指出要使用哪个字符串，而`C++ string`类对象使用对象名和句点运算符来指出要使用哪个字符串。

### String 类`I/O`

使用`cin`和运算符`<<`来将输入存储到`string`对象中，使用`cout`和运算符`<<`来显示`string`对象，
其句法与处理 C-风格字符串相同。但每次读取一行而不是一个单词时，使用的句法不同，下面的程序说明了这一点：

```cpp copy filename="strtype4.cpp"
#include <cstring>
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr[20];
  string str;

  cout << "Length of string in charr before input: "
       << strlen(charr) << endl;
  cout << "Length of string in str before input: "
       << str.size() << endl;
  cout << "Enter a line of text:\n";
  cin.getline(charr, 20);
  cout << "You entered: " << charr << endl;
  cout << "Enter another line of text:\n";
  getline(cin, str); // cin now an argument; no length specifier
  cout << "You entered: " << str << endl;
  cout << "Length of string in charr after input: "
       << strlen(charr) << endl;
  cout << "Length of string in str after input: "
       << str.size() << endl;
  return 0;
}
```

下面是一个运行该程序时的输出示例：

```bash
Length of string in charr before input: 6
Length of string in str before input: 0
Enter a line of text:
peanut butter
You entered: peanut butter
Enter another line of text:
blueberry jam
You entered: blueberry jam
Length of string in charr after input: 13
Length of string in str after input: 13
```

在用户输入之前，该程序指出数组`charr`中的字符串长度为`27`，这比该数组的长度要大。
这里要两点需要说明。首先，未初始化的数组的内容是未定义的；其次，函数`strlen()`从数组的第一个元素开始计算字节数，
直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的，
因此在运行该程序时，得到的数组长度很可能与此不同。

另外，用户输入之前，`str`中的字符串长度为 0。这是因为未被初始化的`string`对象的长度被自动设置为 0。

下面是将一行输入读取到数组中的代码：

```cpp
cin.getline(charr, 20);
```

这种句点表示法表明，函数`getline()`是`istream`类的一个类方法（还记得吗，cin 是一个 istream 对象）。
正如前面指出的，第一个参数是目标数组；第二个参数数组长度，`getline()`使用它来**避免超越数组的边界**。

下面是将一行输入读取到`string`对象中的代码：

```cpp
getline(cin, str);
```

这里没有使用句点表示法，这表明这个`getline()`不是**类方法**。
它将`cin`作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度的参数，
因为`string`对象将**根据字符串的长度自动调整自己的大小**。

<Callout type="info">

那么，为何一个`getline()`是`istream`的类方法，而另一个不是呢？在引入`string`类之前很久，
C++就有`istream`类。因此`istream`的设计考虑到了诸如`double`和`int`等基本`C++`数据类型，
但没有考虑`string`类型，所以`istream`类中，有处理`double`、`int`和其他基本类型的类方法，
但没有处理`string`对象的类方法。

由于 istream 类中没有处理 string 对象的类方法，因此您可能会问，下述代码为何可行呢？

```cpp
cin >> str; // read a word into the str string object
```

处理`string`对象的代码使用`string`类的一个友元函数。有关友元函数及这种技术为何可行，
将在第 11 章介绍。另外，您可以将`cin`和`cout`用于`string`对象，而不用考虑其内部工作原理。

</Callout>

### 其他形式的字符串字面值

本书前面说过，除`char`类型外，C++还有类型`wchar_t`；而 C++11 新增了类型`char16_t`和`char32_t`。
可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分别使用前缀`L`、`u`和`U`表示，
下面是一个如何使用这些前缀的例子：

```cpp
wchar_t title[] = L"Chief Astrogator";
char16_t name[] = u"Felonia Ripova";
char32_t car[] = U"Humver Super Snipe";
```

C++11 还支持`Unicode`字符编码方案`UTF-8`。在这种方案中，根据编码的数字值，
字符可能存储为 1 ～ 4 个八位组。C++使用前缀`u8`来表示这种类型的字符串字面值。

C++11 新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，
例如，序列`\n`不表示换行符，而表示两个常规字符—斜杠和 n，因此在屏幕上显示时，将显示这两个字符。
另一个例子是，可在字符串中使用`"`，而无需像之前那样使用繁琐的`\"`。当然，既然可在字符串字面量包含`"`，
就不能再使用它来表示字符串的开头和末尾。因此，原始字符串将` "``( `和` )``" `用作定界符，
并使用前缀`R`来标识原始字符串：

```cpp
cout << R"(JIM "King" Tutt uses "\n" instead of endl.)" << '\n';
```

上述代码将显示如下内容：

```bash
JIM "King" Tutt uses "\n" instead of endl.
```

## 结构体

结构体是一种比数组更灵活的数据格式，因为同一个结构体可以存储多种类型的数据，
这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。
如果要跟踪整个球队，则可以使用结构体数组。结构体也是`C++ OOP`类的基石。

结构体是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。
因此创建结构体包括两步。首先，定义结构描述—它描述并标记了能够存储在结构体中的各种数据类型。
然后按描述创建结构体变量（结构数据对象）。

例如，假设`Bloataire`公司要创建一种类型来描述其生产线上充气产品的成员。
具体地说，这种类型应存储产品名称、容量（单位为立方英尺）和售价。下面的结构描述能够满足这些要求：

```cpp
struct inflatable // structure declaration
{
  char name[20];
  float volume;
  double price;
};
```

![img](https://files.catbox.moe/8azm8l.png)

定义结构后，便可以创建这种类型的变量了：

```cpp
inflatable hat; // hat is a structure variable of type inflatable
inflatable woople_cushion; // type inflatable variable
```

如果熟悉 C 语言中的结构体，则可能已经注意到了，C++允许在声明结构体变量时省略关键字`struct`：

```cpp
struct inflatable goose; // keyword struct required in C
inflatable vincet;  // keyword struct not required in C++
```

> 在 C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在 C++中，省略`struct`不会出错。

<Callout type="info">

由于`hat`的类型为`inflatable`，因此可以使用成员运算符（`.`）来访问各个成员。
例如，`hat.volume`指的是结构体的`volume`成员，`hat.price`指的是`price`成员。
同样，`vincent.price`是`vincent`变量的`price`成员。总之，通过成员名能够访问结构体的成员，
就像通过索引能够访问数组的元素一样。由于`price`成员被声明为`double`类型，
因此`hat.price`和`vincent.price`相当于是`double`类型的变量，
可以像使用常规`double`变量那样来使用它们。总之，**`hat`是一个结构体，而`hat.price`是一个`double`变量**。
顺便说一句，访问类成员函数（如`cin.getline()`）的方式是从访问结构成员变量（如`vincent.price`）的方式衍生而来的。

</Callout>

### 在程序中使用结构体

先来看下面这个程序：

```cpp copy filename="structur.cpp"
#include <iostream>

struct inflatable
{
  char name[20];
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable guest = {"Glorious Gloria", 1.88, 29.99};
  inflatable pal = {"Audacious Arthur", 3.12, 32.99};
  // NOTE: some implementations requires using static
  cout << "Expand your guest list with " << guest.name;
  cout << " and " << pal.name << "!\n";
  // pal.name is the name member of the pal variable
  cout << "You can have both for $";
  cout << guest.price + pal.price << "!\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Expand your guest list with Glorious Gloria and Audacious Arthur!
You can have both for $62.98!
```

结构体声明的位置很重要。对于`structur.cpp`而言，有两种选择。

- 将声明放在`main()`函数中，紧跟在开始括号的后面。
- 将声明放到`main()`的前面。

> 外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。

<Callout type="info">

变量也可以在函数内部和外部定义，外部变量由所有的函数共享。C++不提倡使用外部变量，
但提倡使用外部结构声明。另外，在外部声明符号常量通常更合理。

</Callout>

```cpp
inflatable guest =
{
  "Glorious Gloria",
  1.88,
  29.99
};
```

和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。
在该程序中，每个值占一行，但也可以将它们全部放在同一行中。
只是应用逗号将它们分开：

```cpp
inflatable duck = { "Daphne", 0.12, 9.98 };
```

可以将结构的每个成员都初始化为适当类型的数据。例如，`name`成员是一个字符数组，因此可以将其初始化为一个字符串。

可将每个结构成员看作是相应类型的变量。因此，`pal.price`是一个`double`变量，
而`pal.name`是一个`char`数组。当程序使用`cout`显示`pal.name`时，将把该成员显示为字符串。
另外，由于`pal.name`是一个字符数组，因此可以用下标来访问其中的各个字符。
例如，`pal.name[0]`是字符 A。不过`pal[0]`没有意义，因为`pal`是一个结构体，而不是数组。

### 结构体初始化

与数组一样，C++11 也支持将列表初始化用于结构，且等号（`=`）是可选的：

```cpp
inflatable duck {"Daphne", 0.12, 9.98};
```

其次，如果大括号内未包含任何东西，各个成员都将被设置为零。例如，下面的声明导致`mayor.volume`和`mayor.price`被设置为零，
且`mayor.name`的每个字节都被设置为零：

```cpp
inflatable mayor {};
```

### 结构可以将`string`类作为成员吗

可以将成员`name`指定为`string`对象而不是字符数组吗？即可以像下面这样声明结构吗？

```cpp
#include <string>
struct inflatable
{
  std::string name;
  float volume;
  double price;
};
```

答案是肯定的，只要您使用的编译器支持对以`string`对象作为成员的结构进行初始化。

一定要让结构定义能够访问名称空间`std`。为此，可以将编译指令`using`移到结构定义之前；
也可以像前面那样，将`name`的类型声明为`std::string`。

### 其他结构属性

C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，
也可以让函数返回一个结构。另外，还可以使用赋值运算符（`=`）将结构赋给另一个同类型的结构，
这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为**成员赋值**
（_memberwise assignment_），下面简要地介绍一下结构赋值:

```cpp copy filename="assgn_st.cpp"
#include <iostream>
#include <string>

struct inflatable
{
  std::string name;
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable bouquet = {"sunflowers", 0.20, 12.49};
  inflatable choice;
  cout << "bouquet: " << bouquet.name << " for $";
  cout << bouquet.price << endl;

  choice = bouquet;
  cout << "choice: " << choice.name << " for $";
  cout << choice.price << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
bouquet: sunflowers for $12.49
choice: sunflowers for $12.49
```

从中可以看出，成员赋值是有效的，因为`choice`结构的成员值与`bouquet`结构中存储的值相同。

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可：

```cpp
struct perks
{
  int key_number;
  char car[12];
} mr_smith, ms_jones; // two perks variables
```

甚至可以初始化以这种方式创建的变量：

```cpp
struct perks
{
  int key_number;
  char car[12];
} mr_glitz =
{
  7,            // value for mr_glitz.key_number member
  "Packard"     // value for mr_glitz.car member
};
```

> 然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解。

还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：

```cpp
struct
{
  int x;
  int y;
} position;
```

这样将创建一个名为`position`的结构变量。可以使用成员运算符来访问它的成员（如`position.x`），
但这种类型没有名称，因此以后无法创建这种类型的变量。

### 结构体数组

`inflatable`结构体包含一个数组（`name`）。也可以创建元素为结构体的数组，
方法和创建基本类型数组完全相同。例如，要创建一个包含 100 个`inflatable`结构体的数组，可以这样做：

```cpp
inflatable gifts[100];
```

这样，`gifts`将是一个`inflatable`数组，其中的每个元素（如`gifts[0]`或`gifts[99]`）都是`inflatable`对象，
可以与成员运算符一起使用：

```cpp
cin >> gifts[0].volume;
cout << gifts[99].price;
```

> 记住，`gifts`本身是一个数组，而不是结构体，因此像`gifts.price`这样的表述是无效的。

要初始化结构体数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）
和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，
因此可以使用结构初始化的方式来提供它的值。因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，
其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：

```cpp
inflatable guest[2] =
{
  {"Bambi", 0.5, 21.99},
  {"Godzilla", 2000, 565.99}
};
```

下面是一个使用结构体数组的简短示例。

```cpp
#include <iostream>
#include <string>
struct inflatable
{
  std::string name;
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable guests[2] =
      {
          {"Bambi", 0.5, 21.99},
          {"Godzilla", 2000, 565.99}};
  cout << "The guests" << guests[0].name << " and " << guests[1].name
       << "\nhave a combined volume of "
       << guests[0].volume + guests[1].volume << " cubic feet.\n";
  return 0;
}
```

下面是该程序的输出：

```bash
The guestsBambi and Godzilla
have a combined volume of 2000.5 cubic feet.
```

### 结构体中的位字段

与 C 语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与**某个硬件设备上的寄存器**对应的数据结构非常方便。
字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
可以使用没有名称的字段来提供间距。每个成员都被称为位字段（`bit field`）。下面是一个例子：

```cpp
struct torgle_register
{
  unsigned int SN : 4;
  unsigned int : 4;
  bool goodIn : 1;
  bool goodTorgle : 1;
};
```

## 共用体

**共用体**（_union_）是一种数据格式，它能够存储不同的数据类型，**但只能同时存储其中的一种类型**。
也就是说，结构可以同时存储`int`、`long`和`double`，共用体只能存储`int`、`long`或`double`。
共用体的句法与结构相似，但含义不同。例如，请看下面的声明：

```cpp
union one4all
{
  int int_val;
  long long_val;
  double double_val;
};

one4all pail;
pail.int_val = 15; // store an int
cout << pail.int_val;
pail.double_val = 1.38; // store a double, int value is lost
cout << pail.double_val;
```

因此，`pail`有时可以是`int`变量，而有时又可以是`double`变量。成员名称标识了变量的容量。
由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，
所以，共用体的长度为**其最大成员的长度**。

<Callout type="info">

共用体的用途之一是，当数据项使用两种或更多种格式（**但不会同时使用**）时，可节省空间。
例如，假设管理一个小商品目录，其中有一些商品的`ID`为整数，而另一些的`ID`为字符串。

</Callout>

```cpp copy
#include <iostream>
#include <string>

struct widget
{
  std::string brand;
  int type;
  union id
  {
    long id_num;
    char id_char[20];
  } id_val;
} prize;

int main(int argc, char const *argv[])
{
  using namespace std;
  cin >> prize.type;
  if (prize.type == 1)
    cin >> prize.id_val.id_num;
  else
    cin >> prize.id_val.id_char;
  return 0;
}
```

**匿名共用体**（_anonymous union_）没有名称，其成员将成为位于相同地址处的变量。
显然，每次只有一个成员是当前的成员：

```cpp
struct widget
{
  std::string brand;
  int type;
  union
  {
    long id_num;
    char id_char[20];
  };
} prize;

```

<Callout type="info">

由于共用体是匿名的，因此`id_num`和`id_char`被视为`prize`的两个成
员，它们的地址相同，所以**不需要中间标识符`id_val`**。程序员负责确定当前哪个成员是活动的。

<Callout>

共用体常用于（但并非只能用于）节省内存。当前，系统的内存多达数 GB 甚至数 TB，好像没有必要节省内存，
但并非所有的 C++程序都是为这样的系统编写的。C++还用于嵌入式系统编程，如控制烤箱、MP3 播放器或火星漫步者的处理器。
对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构。

## 枚举

C++的`enum`工具提供了另一种创建符号常量的方式，这种方式可以代替`const`。
它还允许定义新类型，但必须按严格的限制进行。使用`enum`的句法与使用结构体相似。
例如，请看下面的语句：

```cpp
enum spectrum { red, orange, yellow, green, blue, violet, indigo, ultraviolet };
```

这条语句完成两项工作。

- 让`spectrum`成为新类型的名称；`spectrum`被称为枚举（_enumeration_），就像`struct`变量被称为结构体一样。
- 将`red`、`orange`、`yellow`等作为符号常量，它们对应整数值`0～7`。这些常量叫作枚举量（_enumerator_）。

在默认情况下，将整数值赋给枚举量，第一个枚举量的值为`0`，第二个枚举量的值为`1`，依次类推。
可以通过显式地指定整数值来覆盖默认值。

可以用枚举名来声明这种类型的变量：

```cpp
spectrum band; // band a variable of type spectrum
```

枚举变量具有一些特殊的属性，下面来看一看。

在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，如下所示：

```cpp
band = blue; // valid, blue is an emumerator
band = 2000; // invalid, 2000 is not an emumerator
```

因此，`spectrum`变量受到限制，只有`8`个可能的值。如果试图将一个非法值赋给它，
则有些编译器将出现编译器错误，而另一些则发出警告。为获得最大限度的可移植性，应将把非`enum`值赋给`enum`变量视为错误。

> 对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算。

枚举量是整型，可被提升为`int`类型，但`int`类型不能自动转换为枚举类型：

```cpp
int color = blue; // valid, spectrum type promoted to int
band = 3; // invalid, int not converted to spectrum
color = 3 + red; // valid, red converted to int
```

虽然在这个例子中，`3`对应的枚举量是`green`，但将`3`赋给`band`将导致类型错误。
不过将`green`赋给`band`是可以的，因为它们都是`spectrum`类型。
同样，有些实现方法没有这种限制。表达式`3 + red`中的加法并非为枚举量定义，但`red`被转换为`int`类型，
因此结果的类型也是`int`。由于在这种情况下，枚举将被转换为`int`，
因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算。

如果`int`值是有效的，则可以通过强制类型转换，将它赋给枚举变量：

```cpp
band = spectrum(3);
```

如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？
结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：

```cpp
band = spectrum(40003); // undefined
```

### 设置枚举量的值

可以使用赋值运算符来显式地设置枚举量的值：

```cpp
enum bits {one = 1, two = 2, three = 3, four = 4, eight = 8};
```

指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：

```cpp
enum bigstep {first, second = 100, third};
```

这里，`first`在默认情况下为`0`。后面没有被初始化的枚举量的值将比其前面的枚举量大`1`。因此，`third`的值为`101`。

最后，可以创建多个值相同的枚举量：

```cpp
enum {zero, null = 0, one, numero_uno = 1};
```

其中，`zero`和`null`都为`0`，`one`和`umero_uno`都为`1`。

### 枚举的取值范围

最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，
增加了可赋给枚举变量的合法值。每个枚举都有取值范围（_range_），通过强制类型转换，
可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
例如，假设`bits`和`myflag`的定义如下：

```cpp
enum bits {one = 1, two = 2, four = 4, eight = 8};
bits myflag;
```

则下面的代码将是合法的：

```cpp
myflag = bits(6);
```

其中`6`不是枚举值，但它位于枚举定义的取值范围内。

取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。
找到大于这个最大值的、最小的`2`的幂，将它减去`1`，得到的便是取值范围的上限。
例如，前面定义的`bigstep`的最大值枚举值是`101`。在`2`的幂中，比这个数大的最小值为`128`，
因此取值范围的上限为`127`。要计算下限，需要知道枚举量的最小值。
如果它不小于`0`，则取值范围的下限为`0`；否则，采用与寻找上限方式相同的方式，但加上负号。
例如，如果最小的枚举量为`−6`，而比它小的、最大的`2`的幂是`−8`（加上负号），因此下限为`−7`。

## 指针和自由存储空间