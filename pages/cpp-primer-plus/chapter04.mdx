import { Callout } from "nextra-theme-docs";

# 复合类型

## 数组

数组（_array_）是一种数据格式，能够存储多个同类型的值。例如，数组可以存储 60 个`int`类型的值
（这些值表示游戏 5 年来的销售量）、12 个`short`值（这些值表示每个月的天数）或 365 个`float`值
（这些值指出一年中每天在食物方面的开销）。每个值都存储在一个独立的数组元素
中，计算机在内存中依次存储数组的各个元素。

要创建数组，可使用声明语句。数组声明应指出以下三点：

- 存储在每个元素中的值的类型
- 数组名
- 数组中的元素数

声明数组的通用格式如下：

```cpp
typeName arrayName[arraySize];
```

表达式`arraySize`指定元素数目，它必须是整型常数（如 10）或`const`值，也可以是常量表达式（如`8 * sizeof（int）`），
即其中所有的值在编译时都是已知的。具体地说，`arraySize`**不能是变量**，变量的值是在程序运行时设置的。
然而，本章稍后将介绍如何使用`new`运算符来避开这种限制。

![img](https://files.catbox.moe/y8ep7y.png)

```cpp copy filename="arrayone.cpp"
// arrayone.cpp -- small arrays of integers
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int yams[3]; // create array with 3 elements
  yams[0] = 7; // assign value to first element
  yams[1] = 8; // assign value to second element
  yams[2] = 6;

  int yamcosts[3] = {20, 30, 5};
  // NOTES: if your c++ compiler or translator can't initialize
  // this array use static int yamcosts[3] instead of int yamcosts[3]

  cout << "Total yams = ";
  cout << yams[0] + yams[1] + yams[2] << endl;
  cout << "The package with " << yams[1] << " yams costs ";
  cout << yamcosts[1] << " cents per yam.\n";
  int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1] + yams[2] * yamcosts[2];
  cout << "The total yam expense is " << total << " cents.\n"
       << endl;
  cout << "\nSize of yams array = " << sizeof yams << " bytes.\n";
  cout << "Size of one element = " << sizeof yams[0] << " bytes.\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Total yams = 21
The package with 8 yams costs 30 cents per yam.
The total yam expense is 410 cents.


Size of yams array = 12 bytes.
Size of one element = 4 bytes.
```

<Callout type="info">

`sizeof`运算符返回类型或数据对象的长度（单位为字节）。注意，如果将 sizeof 运算符用于数组名，
得到的将是整个数组中的字节数。但如果将`sizeof`用于数组元素，则得到的将是元素的长度（单位为字节）。
这表明`yams`是一个数组，而`yams[1]`只是一个`int`变量。

</Callout>

### 数组的初始化规则

`C++`有几条关于初始化数组的规则，它们限制了初始化的时刻，决定了数组的元素数目与初始化器中值的数目不相同时将发生的情况。
我们来看看这些规则。

只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

```cpp
int cards[4] = { 3, 6, 8, 10 };
int hand[4];
hand[4] = { 5, 6, 7, 8 }; // not allowed
hand = cards; // not allowed
```

然而，可以使用下标分别给数组中的元素赋值。

初始化数组时，提供的值可以少于数组的元素数目。例如，下面的语句只初始化`hotelTips`的前两个元素：

```cpp
float hotelTips[5] = { 5.0, 2.5 };
```

如果只对数组的一部分进行初始化，则编译器将把其他元素设置为`0`。
因此，将数组中所有的元素都初始化为 0 非常简单—只要显式地将第一个元素初始化为 0，然后让编译器将其他元素都初始化为 0 即可：

```cpp
long totals[500] = { 0 };
```

> 如果初始化为`{1}`而不是`{0}`，则第一个元素被设置为 1，其他元素都被设置为 0。

如果初始化数组时方括号内（`[]`）为空，C++编译器将计算元素个数。例如，对于下面的声明:

```cpp
short things[] = { 1, 5, 3, 8 };
```

编译器将使`things`数组包含 4 个元素。

### 数组初始化方法

C++11 将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化，
但 C++11 中的列表初始化新增了一些功能。

首先，初始化数组时，可省略等号（`=`）：

```cpp
double earnings[4] { 1.24e4, 1.6e4, 1.1e4, 1.7e4 };
```

其次，可不在大括号内包含任何东西，这将把所有元素都设置为零：

```cpp
unsigned int counts[10] = {};
float balances[100] {};
```

第三，列表初始化禁止缩窄转换，这在第 3 章介绍过：

```cpp
long plifs[] = { 25, 92, 3.0 }; // not allowed
char slifs[4] = { 'h', 'i', 1122011, '\0' }; // not allowed
char tlifs[4] = { 'h', 'i', 112, '\0' }; // allowed
```

在上述代码中，第一条语句不能通过编译，因为**将浮点数转换为整型是缩窄操作**，即使浮点数的小数点后面为零。
第二条语句也不能通过编译，因为`1122011`超出了`char`变量的取值范围（这里假设 char 变量的长度为 8 位）。
第三条语句可通过编译，因为虽然 112 是一个`int`值，但它在`char`变量的取值范围内。

C++标准模板库（STL）提供了一种数组替代品—模板类`vector`，而 C++11 新增了模板类 array。
这些替代品比内置复合类型数组更复杂、更灵活，本章将简要地讨论它们，而第 16 章将更详细地讨论它们。

## 字符串

C++处理字符串的方式有两种。第一种来自 C 语言，常被称为 C-风格字符串（_C-style string_）。

C-风格字符串具有一种特殊的性质：以空字符（_null character_）结尾，空字符被写作`\0`，
其`ASCII`码为`0`，用来标记字符串的结尾。例如，请看下面两个声明：

```cpp
char dog[8] = { 'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I' }; // not a string
char cat[8] = { 'f', 'a', 't', 'e', 's', 's', 'a', '\0' }; // a string
```

这两个数组都是`char`数组，但只有第二个数组是字符串。空字符对 C-风格字符串而言至关重要。
例如，C++有很多处理字符串的函数，其中包括`cout`使用的那些函数。它们都逐个地处理字符串中的字符，
**直到到达空字符为止**。如果使用`cout`显示上面的`cat`这样的字符串，则将显示前 7 个字符，发现空字符后停止。
但是，如果使用`cout`显示上面的`dog`数组（它不是字符串），`cout`将打印出数组中的 8 个字母，
**并接着将内存中随后的各个字节解释为要打印的字符**，直到遇到空字符为止。
由于空字符（实际上是被设置为 0 的字节）在内存中很常见，因此这一过程将很快停止。
但尽管如此，还是不应将不是字符串的字符数组当作字符串来处理。

在`cat`数组示例中，将数组初始化为字符串的工作看上去冗长乏味—使用大量单引号，
且必须记住加上空字符。不必担心，有一种更好的、将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串即可，
这种字符串被称为**字符串常量**（_string constant_）或**字符串字面值**（_string literal_），如下所示：

```cpp
char bird[11] = "Mr. Cheeps"; // the \0 is understood
char fish[] = "Bubbles"; // let the compiler count
```

<Callout type="info">

用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。
另外，各种`C++`输入工具通过键盘输入，将字符串读入到`char`数组中时，将自动加上结尾的空字符。

当然，应确保数组足够大，能够存储字符串中所有字符—包括空字符。
使用字符串常量初始化字符数组是这样的一种情况，即**让编译器计算元素数目更为安全**。
让数组比字符串长没有什么害处，只是会浪费一些空间而已。
这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。

</Callout>

![img](https://files.catbox.moe/06201j.png)

注意，字符串常量（使用双引号）不能与字符常量（使用单引号）互换。
字符常量（如`'S'`）是字符串编码的简写表示。在`ASCII`系统上，`'S'`只是 83 的另一种写法，因此，
下面的语句将`83`赋给`shirt_size`：

```cpp
short size = 'S'; // legal
short shirt_size = "S"; // illegal type mismatch
```

<Callout type="error">

`"S"`不是字符常量，它表示的是两个字符（字符 S 和\0）组成的字符串。
更糟糕的是，`"S"`实际上表示的是**字符串所在的内存地址**。
因此语句试图将一个内存地址赋给`shirt_size`，显然是不合法的。

</Callout>

### 拼接字符串常量

有时候，字符串很长，无法放到一行中。C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。
事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。
因此，下面所有的输出语句都是等效的：

```cpp copy
std::cout << "I'd give my right arm to be" " a great violinist.\n";
std::cout << "I'd give my right arm to be a great violinist.\n";
std::cout << "I'd give my right ar" "m to be a great violinist.\n";
```

<Callout type="warning">

注意，拼接时不会在被连接的字符串之间添加空格，
第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑`\0`）后面。
**第一个字符串中的`\0`字符将被第二个字符串的第一个字符取代**。

</Callout>

### 在数组中使用字符串

要将字符串存储到数组中，最常用的方法有两种—将数组初始化为字符串常量、将键盘或文件输入读入到数组中。

```cpp copy filename="string.cpp"
#include <cstring>
#include <iostream>
int main(int argc, char const *argv[])
{
  using namespace std;
  const int Size = 15;
  char name1[Size];
  char name2[Size] = "C++owboy";

  // NOTE: some implementations may require the static keyword
  // to initialize the array name2
  cout << "Howdy! I'm " << name2;
  cout << "! What's your name?\n";
  cin >> name1;

  cout << "Well, " << name1 << ", your name has ";
  cout << strlen(name1) << " letters and is stored\n";
  cout << "in an array of " << sizeof(name1) << " bytes.\n";

  cout << "Your initial is " << name1[0] << ".\n";
  name2[3] = '\0';
  cout << "Here are the fiest 3 characters of my name: ";
  cout << name2 << endl;
  return 0;
}
```

下面是该程序的运行情况：

```bash

Howdy! I'm C++owboy! What's your name?
tohsaka888
Well, tohsaka888, your name has 10 letters and is stored
in an array of 15 bytes.
Your initial is t.
Here are the fiest 3 characters of my name: C++
```

<Callout type="tip">

该程序使用符号常量来指定数组的长度。程序常常有多条语句使用了数组长度。
使用符号常量来表示数组长度后，当需要修改程序以使用不同的数组长度时，
工作将变得更简单—只需在定义符号常量的地方进行修改即可。

</Callout>

![img](https://files.catbox.moe/yy2pch.png)

### 字符串输入

程序`strings.cpp`有一个缺陷，这种缺陷通过精心选择输入被掩盖掉了。
下面的程序，揭示了字符串输入的技巧。

```cpp copy filename="instr1.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "Enter your name:\n";
  cin >> name;
  cout << "Enter your favourite dessert:\n";
  cin >> dessert;
  cout << "I have some delicious " << dessert;
  cout << " for you, " << name << "\n";
  return 0;
}
```

该程序的意图很简单：读取来自键盘的用户名和用户喜欢的甜点，然后显示这些信息。下面是该程序的运行情况：

```bash
Enter your name:
Alistair Dreeb
Enter your favourite dessert:
I have some delicious Dreeb for you, Alistair
```

我们甚至还没有对“输入甜点的提示”作出反应，程序便把它显示出来了，然后立即显示最后一行。

`cin`是如何确定已完成字符串输入呢？由于不能通过键盘输入空字符，因此`cin`需要用别的方法来确定字符串的结尾位置。
`cin`使用**空白（空格、制表符和换行符）来确定字符串的结束位置**，这意味着`cin`在获取字符数组输入时只读取一个单词。
读取该单词后，`cin`将该字符串放到数组中，并自动在结尾添加空字符。

这个例子的实际结果是，`cin`把`Alistair`作为第一个字符串，并将它放到`name`数组中。
这把`Dreeb`留在输入队列中。当`cin`在输入队列中搜索用户喜欢的甜点时，它发现了`Dreeb`，
因此`cin`读取`Dreeb`，并将它放到`dessert`数组中。

![img](https://files.catbox.moe/hwf1n4.png)

另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出来）。
像这个例子一样使用`cin`，确实不能防止将包含 30 个字符的字符串放到 20 个字符的数组中的情况发生。

### 每次读取一行的字符串输入

#### 面向行输出：`getline()`

`getline()`函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
要调用这种方法，可以使用`cin.getline()`。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，
第二个参数是要读取的字符数。如果这个参数为 20，则函数最多读取 19 个字符，余下的空间用于存储自动在结尾处添加的空字符。
`getline()`成员函数在读取指定数目的字符或遇到换行符时停止读取。

例如，假设要使用`getline()`将姓名读入到一个包含 20 个元素的`name`数组中。可以使用这样的函数调用：

```cpp
cin.getline(name, 20);
```

> 这将把一行读入到`name`数组中—如果这行包含的字符不超过 19 个。

```cpp copy filename="instr2.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  const int ArSize = 20;
  char name[ArSize];
  char dessert[ArSize];

  cout << "Enter your name:\n";
  cin.getline(name, ArSize); // reads through newline
  cout << "Enter your favorite dessert:\n";
  cin.getline(dessert, ArSize); // reads through newline
  cout << "I have some delicious " << dessert;
  cout << " for you, " << name << ".\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Enter your name:
Elon Mask
Enter your favorite dessert:
shit
I have some delicious shit for you, Elon Mask.
```

![img](https://files.catbox.moe/dakuls.png)

#### 面向行的输入：`get()`

`istream`类有另一个名为`get()`的成员函数，该函数有几种变体。其中一种变体的工作方式与`getline()`类似，
它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但`get`并不再读取并丢弃换行符，而是将其留在输入队列中。
假设我们连续两次调用`get()`：

```cpp
cin.get(name, ArSize);
cin.get(dessert, ArSize);
```

由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。
因此`get()`认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，`get()`将不能跨过该换行符。

> 也就是说第二次的`get()`会读取到一个换行符。

幸运的是，`get()`有另一种变体。使用不带任何参数的`cin.get()`调用可读取下一个字符（即使是换行符），
因此可以用它来处理换行符，为读取下一行输入做好准备。也就是说，可以采用下面的调用序列：

```cpp
cin.get(name, ArSize);
cin.get();
cin.get(dessert, ArSize);
```

另一种使用`get()`的方式是将两个类成员函数拼接起来（合并），如下所示：

```cpp
cin.get(name, ArSize).get(); // concatenate member functions
```

之所以可以这样做，是由于`cin.get(name, ArSize)`返回一个`cin`对象，该对象随后将被用来调用`get()`函数。
同样，下面的语句将把输入中连续的两行分别读入到数组`name1`和`name2`中，其效果与两次调用`cin.getline()`相同：

```cpp
cin.getline(name1, ArSize).getline(name2, ArSize);
```

### 混合输入字符串和数字

混合输入数字和面向行的字符串会导致问题。

```cpp copy filename="numstr.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  cout << "What year was your house built?\n";
  int year;
  cin >> year;
  cout << "What is its street address?\n";
  char address[80];
  cin.getline(address, 80);
  cout << "Year built: " << year << endl;
  cout << "Address: " << address << endl;
  cout << "Done!\n";
  return 0;
}
```

该程序的运行情况如下：

```bash

What year was your house built?
1966
What is its street address?
Year built: 1966
Address:
Done!
```

用户根本没有输入地址的机会。问题在于，当`cin`读取年份，将回车键生成的换行符留在了输入队列中。
后面的`cin.getline()`看到换行符后，将认为是一个空行，并将一个空字符串赋给`address`数组。
解决之道是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完成，
其中包括使用没有参数的`get()`和使用接受一个`char`参数的`get()`，
如前面的例子所示。可以单独进行调用:

```cpp copy
cin >> years;
cin.get();
```

也可以利用表达式`cin>>year`返回`cin`对象，将调用拼接起来：

```cpp copy
(cin >> year).get();
```

## `String`类简介

要使用`string`类，必须在程序中包含头文件`string`。`string`类位于名称空间`std`中，
因此您必须提供一条`using`编译指令，或者使用`std::string`来引用它。
`string`类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串。
下面程序说明了`string`对象与字符数组之间的一些相同点和不同点。

```cpp copy filename="strtype1.cpp"
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr1[20];            // create an empty array
  char charr2[20] = "jaguar"; // create an initialized array
  string str1;                //  create an empty string object
  string str2 = "panther";    // create an initialized string

  cout << "Enter a kind of feline: ";
  cin >> charr1;
  cout << "Enter another kind of feline: ";
  cin >> str1;
  cout << "Here are some felines:\n";
  cout << charr1 << " " << charr2 << " "
       << str1 << " " << str2 << endl;
  cout << "The third letter in " << charr2 << " is " << charr2[2] << endl;
  cout << "The third letter in " << str2 << " is " << str2[2] << endl; // use array notation
  return 0;
}
```

从这个示例可知，在很多方面，使用`string`对象的方式与使用字符数组相同。

- 可以使用 C-风格字符串来初始化`string`对象。
- 可以使用`cin`来将键盘输入存储到`string`对象中。
- 可以使用`cout`来显示`string`对象。
- 可以使用数组表示法来访问存储在`string`对象中的字符。

`string`对象和字符数组之间的主要区别是，可以将`string`对象声明为简单变量，而不是数组：

```cpp
string str1;  // create an empty string object
string str2 = "panther";  // create an initialized string
```

类设计让程序能够自动处理`string`的大小。例如，`str1`的声明创建一个长度为 0 的`string`对象，
但程序将输入读取到`str1`中时，将自动调整`str1`的长度：

```cpp
cin >> str1; // str1 resized to fit input
```

这使得与使用数组相比，使用`string`对象更方便，也更安全。
从理论上说，可以将`char`数组视为一组用于存储一个字符串的`char`存储单元，而`string`类变量是一个表示字符串的实体。

## 字符串初始化

C++11 也允许将列表初始化用于 C-风格字符串和`string`对象:

```cpp
char first_date[] = { "Le Chapon Dodu" };
char second_date[] = { "The Elegant Plate" };
string third_date[] = { "The Bread Bowl" };
string fourth_date[] = { "Hank's Fine Eats" };
```

## 赋值、拼接和附加

使用`string`类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，
但可以将一个`string`对象赋给另一个`string`对象：

```cpp
char charr1[20]; // create an empty array
char charr2[20] = "jaguar"; // create an initialized array
string str1; // create an empty string object
string str2 = "pather"; // create an initialized string
charr1 = charr2; // INVALID, no array assignment
str1 = str2; // INVALID, object assignment ok
```

`string`类简化了字符串合并操作。可以使用运算符`+`将两个`string`对象合并起来，
还可以使用运算符`+=`将字符串附加到`string`对象的末尾。继续前面的代码，您可以这样做：

```cpp
string str3;
str3 = str1 + str2;
str1 += str2;
```

下面的程序演示了这些用法。可以将 C-风格字符串或 `string` 对象与`string` 对象相加，
或将它们附加到 `string` 对象的末尾。

```cpp
#include <iostream>
#include <string>
int main(int argc, char const *argv[])
{
  using namespace std;
  string s1 = "penguin";
  string s2, s3;

  cout << "You can assign one string object to another: s2 = s1\n";
  s2 = s1;
  cout << "s1: " << s1 << ", s2: " << s2 << endl;
  cout << "You can assign a C-style string to a string object.\n";
  cout << "s2 = \"buzzard\"\n";
  s2 = "buzzard";
  cout << "s2: " << s2 << endl;
  cout << "You can concatenate strings: s3 = s1 + s2\n";
  s3 = s1 + s2;
  cout << "s3: " << s3 << endl;
  cout << "You can append strings.\n";
  s1 += s2;
  cout << "s1 += s2 yields s1 = " << s1 << endl;
  s2 += " for a day";
  cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;
  return 0;
}
```

转义序列`\"`表示双引号，而不是字符串结尾。该程序的输出如下：

```bash
You can assign one string object to another: s2 = s1
s1: penguin, s2: penguin
You can assign a C-style string to a string object.
s2 = "buzzard"
s2: buzzard
You can concatenate strings: s3 = s1 + s2
s3: penguinbuzzard
You can append strings.
s1 += s2 yields s1 = penguinbuzzard
s2 += " for a day" yields s2 = buzzard for a day
```

### string 类的其他操作

在 C++新增`string`类之前，程序员也需要完成诸如给字符串赋值等工作。
对于 C-风格字符串，程序员使用 C 语言库中的函数来完成这些任务。
头文件`cstring`（以前为`string.h`）提供了这些函数。
例如，可以使用函数`strcpy()`将**字符串复制到字符数组**中，
使用函数`strcat()`将**字符串附加到字符数组末尾**。

```cpp
strcpy(charr1, charr2); // copy charr1 to charr2
strcat(charr1, charr2); // append contents of charr2 to charr1
```

下面的程序对用于`string`对象的技术和用于字符数组的技术进行了比较。

```cpp copy filename="strtype3.cpp"
#include <cstring>
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr1[20];
  char charr2[20] = "jaguar";
  string str1;
  string str2 = "panther";

  // assignment for string objects and character arrays
  str1 = str2;            // copy str2 to str1
  strcpy(charr1, charr2); // copy charr2 to charr1

  // appending for string objects and character arrays
  str1 += " paste";
  strcat(charr1, " juice");

  // finding the length of a string object and C-style string
  int len1 = str1.size();
  int len2 = strlen(charr1);

  cout << "The string " << str1 << " contains " << len1 << " characters." << endl;
  cout << "The string " << charr1 << " contains " << len2 << " characters." << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
The string panther paste contains 13 characters.
The string jaguar juice contains 12 characters.
```

处理`string`对象的语法通常比使用 C 字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：

```cpp
str3 = str1 + str2;
```

使用 C-风格字符串时，需要使用的函数如下：

```cpp
strcpy(charr3, charr1);
strcpy(charr3, charr2);
```

另外，使用字符数组时，总是存在**目标数组过小**，无法存储指定信息的危险，如下面的示例所示：

```cpp
char site[10] = "house";
strcat(site, " of pancakes");  // memory problem
```

函数`strcat()`试图将全部 12 个字符复制到数组`site`中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，
但数据被损坏。`string`类具有**自动调整大小**的功能，从而能够避免这种问题发生。
C 函数库确实提供了与`strcat()`和`strcpy()`类似的函数—`strncat()`和`strncpy()`，
它们接受指出目标数组最大允许长度的第三个参数，因此更为安全，但使用它们进一步增加了编写程序的复杂度。

下面是两种确定字符串中字符数的方法：

```cpp
int len1 = str1.size();
int len2 = strlen(charr1);
```

函数`strlen()`是一个常规函数，它接受一个 C-风格字符串作为参数，并返回该字符串包含的字符数。
函数`size()` 的功能基本上与此相同，但句法不同：`str1`不是被用作函数参数，而是位于函数名之前，
它们之间用句点连接。与第 3 章介绍的`put()`方法相同，这种句法表明，`str1`是一个对象，
而`size()` 是一个类方法。方法是一个函数，只能通过其所属类的对象进行调用。
在这里，`str1`是一个`string`对象，而`size()`是`string`类的一个方法。
总之，C 函数使用参数来指出要使用哪个字符串，而`C++ string`类对象使用对象名和句点运算符来指出要使用哪个字符串。

### String 类`I/O`

使用`cin`和运算符`<<`来将输入存储到`string`对象中，使用`cout`和运算符`<<`来显示`string`对象，
其句法与处理 C-风格字符串相同。但每次读取一行而不是一个单词时，使用的句法不同，下面的程序说明了这一点：

```cpp copy filename="strtype4.cpp"
#include <cstring>
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  char charr[20];
  string str;

  cout << "Length of string in charr before input: "
       << strlen(charr) << endl;
  cout << "Length of string in str before input: "
       << str.size() << endl;
  cout << "Enter a line of text:\n";
  cin.getline(charr, 20);
  cout << "You entered: " << charr << endl;
  cout << "Enter another line of text:\n";
  getline(cin, str); // cin now an argument; no length specifier
  cout << "You entered: " << str << endl;
  cout << "Length of string in charr after input: "
       << strlen(charr) << endl;
  cout << "Length of string in str after input: "
       << str.size() << endl;
  return 0;
}
```

下面是一个运行该程序时的输出示例：

```bash
Length of string in charr before input: 6
Length of string in str before input: 0
Enter a line of text:
peanut butter
You entered: peanut butter
Enter another line of text:
blueberry jam
You entered: blueberry jam
Length of string in charr after input: 13
Length of string in str after input: 13
```

在用户输入之前，该程序指出数组`charr`中的字符串长度为`27`，这比该数组的长度要大。
这里要两点需要说明。首先，未初始化的数组的内容是未定义的；其次，函数`strlen()`从数组的第一个元素开始计算字节数，
直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的，
因此在运行该程序时，得到的数组长度很可能与此不同。

另外，用户输入之前，`str`中的字符串长度为 0。这是因为未被初始化的`string`对象的长度被自动设置为 0。

下面是将一行输入读取到数组中的代码：

```cpp
cin.getline(charr, 20);
```

这种句点表示法表明，函数`getline()`是`istream`类的一个类方法（还记得吗，cin 是一个 istream 对象）。
正如前面指出的，第一个参数是目标数组；第二个参数数组长度，`getline()`使用它来**避免超越数组的边界**。

下面是将一行输入读取到`string`对象中的代码：

```cpp
getline(cin, str);
```

这里没有使用句点表示法，这表明这个`getline()`不是**类方法**。
它将`cin`作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度的参数，
因为`string`对象将**根据字符串的长度自动调整自己的大小**。

<Callout type="info">

那么，为何一个`getline()`是`istream`的类方法，而另一个不是呢？在引入`string`类之前很久，
C++就有`istream`类。因此`istream`的设计考虑到了诸如`double`和`int`等基本`C++`数据类型，
但没有考虑`string`类型，所以`istream`类中，有处理`double`、`int`和其他基本类型的类方法，
但没有处理`string`对象的类方法。

由于 istream 类中没有处理 string 对象的类方法，因此您可能会问，下述代码为何可行呢？

```cpp
cin >> str; // read a word into the str string object
```

处理`string`对象的代码使用`string`类的一个友元函数。有关友元函数及这种技术为何可行，
将在第 11 章介绍。另外，您可以将`cin`和`cout`用于`string`对象，而不用考虑其内部工作原理。

</Callout>

### 其他形式的字符串字面值

本书前面说过，除`char`类型外，C++还有类型`wchar_t`；而 C++11 新增了类型`char16_t`和`char32_t`。
可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分别使用前缀`L`、`u`和`U`表示，
下面是一个如何使用这些前缀的例子：

```cpp
wchar_t title[] = L"Chief Astrogator";
char16_t name[] = u"Felonia Ripova";
char32_t car[] = U"Humver Super Snipe";
```

C++11 还支持`Unicode`字符编码方案`UTF-8`。在这种方案中，根据编码的数字值，
字符可能存储为 1 ～ 4 个八位组。C++使用前缀`u8`来表示这种类型的字符串字面值。

C++11 新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，
例如，序列`\n`不表示换行符，而表示两个常规字符—斜杠和 n，因此在屏幕上显示时，将显示这两个字符。
另一个例子是，可在字符串中使用`"`，而无需像之前那样使用繁琐的`\"`。当然，既然可在字符串字面量包含`"`，
就不能再使用它来表示字符串的开头和末尾。因此，原始字符串将` "``( `和` )``" `用作定界符，
并使用前缀`R`来标识原始字符串：

```cpp
cout << R"(JIM "King" Tutt uses "\n" instead of endl.)" << '\n';
```

上述代码将显示如下内容：

```bash
JIM "King" Tutt uses "\n" instead of endl.
```

## 结构体

结构体是一种比数组更灵活的数据格式，因为同一个结构体可以存储多种类型的数据，
这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。
如果要跟踪整个球队，则可以使用结构体数组。结构体也是`C++ OOP`类的基石。

结构体是用户定义的类型，而结构声明定义了这种类型的数据属性。定义了类型后，便可以创建这种类型的变量。
因此创建结构体包括两步。首先，定义结构描述—它描述并标记了能够存储在结构体中的各种数据类型。
然后按描述创建结构体变量（结构数据对象）。

例如，假设`Bloataire`公司要创建一种类型来描述其生产线上充气产品的成员。
具体地说，这种类型应存储产品名称、容量（单位为立方英尺）和售价。下面的结构描述能够满足这些要求：

```cpp
struct inflatable // structure declaration
{
  char name[20];
  float volume;
  double price;
};
```

![img](https://files.catbox.moe/8azm8l.png)

定义结构后，便可以创建这种类型的变量了：

```cpp
inflatable hat; // hat is a structure variable of type inflatable
inflatable woople_cushion; // type inflatable variable
```

如果熟悉 C 语言中的结构体，则可能已经注意到了，C++允许在声明结构体变量时省略关键字`struct`：

```cpp
struct inflatable goose; // keyword struct required in C
inflatable vincet;  // keyword struct not required in C++
```

> 在 C++中，结构标记的用法与基本类型名相同。这种变化强调的是，结构声明定义了一种新类型。在 C++中，省略`struct`不会出错。

<Callout type="info">

由于`hat`的类型为`inflatable`，因此可以使用成员运算符（`.`）来访问各个成员。
例如，`hat.volume`指的是结构体的`volume`成员，`hat.price`指的是`price`成员。
同样，`vincent.price`是`vincent`变量的`price`成员。总之，通过成员名能够访问结构体的成员，
就像通过索引能够访问数组的元素一样。由于`price`成员被声明为`double`类型，
因此`hat.price`和`vincent.price`相当于是`double`类型的变量，
可以像使用常规`double`变量那样来使用它们。总之，**`hat`是一个结构体，而`hat.price`是一个`double`变量**。
顺便说一句，访问类成员函数（如`cin.getline()`）的方式是从访问结构成员变量（如`vincent.price`）的方式衍生而来的。

</Callout>

### 在程序中使用结构体

先来看下面这个程序：

```cpp copy filename="structur.cpp"
#include <iostream>

struct inflatable
{
  char name[20];
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable guest = {"Glorious Gloria", 1.88, 29.99};
  inflatable pal = {"Audacious Arthur", 3.12, 32.99};
  // NOTE: some implementations requires using static
  cout << "Expand your guest list with " << guest.name;
  cout << " and " << pal.name << "!\n";
  // pal.name is the name member of the pal variable
  cout << "You can have both for $";
  cout << guest.price + pal.price << "!\n";
  return 0;
}
```

下面是该程序的输出：

```bash
Expand your guest list with Glorious Gloria and Audacious Arthur!
You can have both for $62.98!
```

结构体声明的位置很重要。对于`structur.cpp`而言，有两种选择。

- 将声明放在`main()`函数中，紧跟在开始括号的后面。
- 将声明放到`main()`的前面。

> 外部声明可以被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。

<Callout type="info">

变量也可以在函数内部和外部定义，外部变量由所有的函数共享。C++不提倡使用外部变量，
但提倡使用外部结构声明。另外，在外部声明符号常量通常更合理。

</Callout>

```cpp
inflatable guest =
{
  "Glorious Gloria",
  1.88,
  29.99
};
```

和数组一样，使用由逗号分隔值列表，并将这些值用花括号括起。
在该程序中，每个值占一行，但也可以将它们全部放在同一行中。
只是应用逗号将它们分开：

```cpp
inflatable duck = { "Daphne", 0.12, 9.98 };
```

可以将结构的每个成员都初始化为适当类型的数据。例如，`name`成员是一个字符数组，因此可以将其初始化为一个字符串。

可将每个结构成员看作是相应类型的变量。因此，`pal.price`是一个`double`变量，
而`pal.name`是一个`char`数组。当程序使用`cout`显示`pal.name`时，将把该成员显示为字符串。
另外，由于`pal.name`是一个字符数组，因此可以用下标来访问其中的各个字符。
例如，`pal.name[0]`是字符 A。不过`pal[0]`没有意义，因为`pal`是一个结构体，而不是数组。

### 结构体初始化

与数组一样，C++11 也支持将列表初始化用于结构，且等号（`=`）是可选的：

```cpp
inflatable duck {"Daphne", 0.12, 9.98};
```

其次，如果大括号内未包含任何东西，各个成员都将被设置为零。例如，下面的声明导致`mayor.volume`和`mayor.price`被设置为零，
且`mayor.name`的每个字节都被设置为零：

```cpp
inflatable mayor {};
```

### 结构可以将`string`类作为成员吗

可以将成员`name`指定为`string`对象而不是字符数组吗？即可以像下面这样声明结构吗？

```cpp
#include <string>
struct inflatable
{
  std::string name;
  float volume;
  double price;
};
```

答案是肯定的，只要您使用的编译器支持对以`string`对象作为成员的结构进行初始化。

一定要让结构定义能够访问名称空间`std`。为此，可以将编译指令`using`移到结构定义之前；
也可以像前面那样，将`name`的类型声明为`std::string`。

### 其他结构属性

C++使用户定义的类型与内置类型尽可能相似。例如，可以将结构作为参数传递给函数，
也可以让函数返回一个结构。另外，还可以使用赋值运算符（`=`）将结构赋给另一个同类型的结构，
这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为**成员赋值**
（_memberwise assignment_），下面简要地介绍一下结构赋值:

```cpp copy filename="assgn_st.cpp"
#include <iostream>
#include <string>

struct inflatable
{
  std::string name;
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable bouquet = {"sunflowers", 0.20, 12.49};
  inflatable choice;
  cout << "bouquet: " << bouquet.name << " for $";
  cout << bouquet.price << endl;

  choice = bouquet;
  cout << "choice: " << choice.name << " for $";
  cout << choice.price << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
bouquet: sunflowers for $12.49
choice: sunflowers for $12.49
```

从中可以看出，成员赋值是有效的，因为`choice`结构的成员值与`bouquet`结构中存储的值相同。

可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可：

```cpp
struct perks
{
  int key_number;
  char car[12];
} mr_smith, ms_jones; // two perks variables
```

甚至可以初始化以这种方式创建的变量：

```cpp
struct perks
{
  int key_number;
  char car[12];
} mr_glitz =
{
  7,            // value for mr_glitz.key_number member
  "Packard"     // value for mr_glitz.car member
};
```

> 然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解。

还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：

```cpp
struct
{
  int x;
  int y;
} position;
```

这样将创建一个名为`position`的结构变量。可以使用成员运算符来访问它的成员（如`position.x`），
但这种类型没有名称，因此以后无法创建这种类型的变量。

### 结构体数组

`inflatable`结构体包含一个数组（`name`）。也可以创建元素为结构体的数组，
方法和创建基本类型数组完全相同。例如，要创建一个包含 100 个`inflatable`结构体的数组，可以这样做：

```cpp
inflatable gifts[100];
```

这样，`gifts`将是一个`inflatable`数组，其中的每个元素（如`gifts[0]`或`gifts[99]`）都是`inflatable`对象，
可以与成员运算符一起使用：

```cpp
cin >> gifts[0].volume;
cout << gifts[99].price;
```

> 记住，`gifts`本身是一个数组，而不是结构体，因此像`gifts.price`这样的表述是无效的。

要初始化结构体数组，可以结合使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）
和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个元素都是结构，
因此可以使用结构初始化的方式来提供它的值。因此，最终结果为一个被括在花括号中、用逗号分隔的值列表，
其中每个值本身又是一个被括在花括号中、用逗号分隔的值列表：

```cpp
inflatable guest[2] =
{
  {"Bambi", 0.5, 21.99},
  {"Godzilla", 2000, 565.99}
};
```

下面是一个使用结构体数组的简短示例。

```cpp
#include <iostream>
#include <string>
struct inflatable
{
  std::string name;
  float volume;
  double price;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable guests[2] =
      {
          {"Bambi", 0.5, 21.99},
          {"Godzilla", 2000, 565.99}};
  cout << "The guests" << guests[0].name << " and " << guests[1].name
       << "\nhave a combined volume of "
       << guests[0].volume + guests[1].volume << " cubic feet.\n";
  return 0;
}
```

下面是该程序的输出：

```bash
The guestsBambi and Godzilla
have a combined volume of 2000.5 cubic feet.
```

### 结构体中的位字段

与 C 语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与**某个硬件设备上的寄存器**对应的数据结构非常方便。
字段的类型应为整型或枚举（稍后将介绍），接下来是冒号，冒号后面是一个数字，它指定了使用的位数。
可以使用没有名称的字段来提供间距。每个成员都被称为位字段（`bit field`）。下面是一个例子：

```cpp
struct torgle_register
{
  unsigned int SN : 4;
  unsigned int : 4;
  bool goodIn : 1;
  bool goodTorgle : 1;
};
```

## 共用体

**共用体**（_union_）是一种数据格式，它能够存储不同的数据类型，**但只能同时存储其中的一种类型**。
也就是说，结构可以同时存储`int`、`long`和`double`，共用体只能存储`int`、`long`或`double`。
共用体的句法与结构相似，但含义不同。例如，请看下面的声明：

```cpp
union one4all
{
  int int_val;
  long long_val;
  double double_val;
};

one4all pail;
pail.int_val = 15; // store an int
cout << pail.int_val;
pail.double_val = 1.38; // store a double, int value is lost
cout << pail.double_val;
```

因此，`pail`有时可以是`int`变量，而有时又可以是`double`变量。成员名称标识了变量的容量。
由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，
所以，共用体的长度为**其最大成员的长度**。

<Callout type="info">

共用体的用途之一是，当数据项使用两种或更多种格式（**但不会同时使用**）时，可节省空间。
例如，假设管理一个小商品目录，其中有一些商品的`ID`为整数，而另一些的`ID`为字符串。

</Callout>

```cpp copy
#include <iostream>
#include <string>

struct widget
{
  std::string brand;
  int type;
  union id
  {
    long id_num;
    char id_char[20];
  } id_val;
} prize;

int main(int argc, char const *argv[])
{
  using namespace std;
  cin >> prize.type;
  if (prize.type == 1)
    cin >> prize.id_val.id_num;
  else
    cin >> prize.id_val.id_char;
  return 0;
}
```

**匿名共用体**（_anonymous union_）没有名称，其成员将成为位于相同地址处的变量。
显然，每次只有一个成员是当前的成员：

```cpp
struct widget
{
  std::string brand;
  int type;
  union
  {
    long id_num;
    char id_char[20];
  };
} prize;

```

<Callout type="info">

由于共用体是匿名的，因此`id_num`和`id_char`被视为`prize`的两个成
员，它们的地址相同，所以**不需要中间标识符`id_val`**。程序员负责确定当前哪个成员是活动的。

</Callout>

共用体常用于（但并非只能用于）节省内存。当前，系统的内存多达数 GB 甚至数 TB，好像没有必要节省内存，
但并非所有的 C++程序都是为这样的系统编写的。C++还用于嵌入式系统编程，如控制烤箱、MP3 播放器或火星漫步者的处理器。
对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构。

## 枚举

C++的`enum`工具提供了另一种创建符号常量的方式，这种方式可以代替`const`。
它还允许定义新类型，但必须按严格的限制进行。使用`enum`的句法与使用结构体相似。
例如，请看下面的语句：

```cpp
enum spectrum { red, orange, yellow, green, blue, violet, indigo, ultraviolet };
```

这条语句完成两项工作。

- 让`spectrum`成为新类型的名称；`spectrum`被称为枚举（_enumeration_），就像`struct`变量被称为结构体一样。
- 将`red`、`orange`、`yellow`等作为符号常量，它们对应整数值`0～7`。这些常量叫作枚举量（_enumerator_）。

在默认情况下，将整数值赋给枚举量，第一个枚举量的值为`0`，第二个枚举量的值为`1`，依次类推。
可以通过显式地指定整数值来覆盖默认值。

可以用枚举名来声明这种类型的变量：

```cpp
spectrum band; // band a variable of type spectrum
```

枚举变量具有一些特殊的属性，下面来看一看。

在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量，如下所示：

```cpp
band = blue; // valid, blue is an emumerator
band = 2000; // invalid, 2000 is not an emumerator
```

因此，`spectrum`变量受到限制，只有`8`个可能的值。如果试图将一个非法值赋给它，
则有些编译器将出现编译器错误，而另一些则发出警告。为获得最大限度的可移植性，应将把非`enum`值赋给`enum`变量视为错误。

> 对于枚举，只定义了赋值运算符。具体地说，没有为枚举定义算术运算。

枚举量是整型，可被提升为`int`类型，但`int`类型不能自动转换为枚举类型：

```cpp
int color = blue; // valid, spectrum type promoted to int
band = 3; // invalid, int not converted to spectrum
color = 3 + red; // valid, red converted to int
```

虽然在这个例子中，`3`对应的枚举量是`green`，但将`3`赋给`band`将导致类型错误。
不过将`green`赋给`band`是可以的，因为它们都是`spectrum`类型。
同样，有些实现方法没有这种限制。表达式`3 + red`中的加法并非为枚举量定义，但`red`被转换为`int`类型，
因此结果的类型也是`int`。由于在这种情况下，枚举将被转换为`int`，
因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算。

如果`int`值是有效的，则可以通过强制类型转换，将它赋给枚举变量：

```cpp
band = spectrum(3);
```

如果试图对一个不适当的值进行强制类型转换，将出现什么情况呢？
结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：

```cpp
band = spectrum(40003); // undefined
```

### 设置枚举量的值

可以使用赋值运算符来显式地设置枚举量的值：

```cpp
enum bits {one = 1, two = 2, three = 3, four = 4, eight = 8};
```

指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：

```cpp
enum bigstep {first, second = 100, third};
```

这里，`first`在默认情况下为`0`。后面没有被初始化的枚举量的值将比其前面的枚举量大`1`。因此，`third`的值为`101`。

最后，可以创建多个值相同的枚举量：

```cpp
enum {zero, null = 0, one, numero_uno = 1};
```

其中，`zero`和`null`都为`0`，`one`和`umero_uno`都为`1`。

### 枚举的取值范围

最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，
增加了可赋给枚举变量的合法值。每个枚举都有取值范围（_range_），通过强制类型转换，
可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值。
例如，假设`bits`和`myflag`的定义如下：

```cpp
enum bits {one = 1, two = 2, four = 4, eight = 8};
bits myflag;
```

则下面的代码将是合法的：

```cpp
myflag = bits(6);
```

其中`6`不是枚举值，但它位于枚举定义的取值范围内。

取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。
找到大于这个最大值的、最小的`2`的幂，将它减去`1`，得到的便是取值范围的上限。
例如，前面定义的`bigstep`的最大值枚举值是`101`。在`2`的幂中，比这个数大的最小值为`128`，
因此取值范围的上限为`127`。要计算下限，需要知道枚举量的最小值。
如果它不小于`0`，则取值范围的下限为`0`；否则，采用与寻找上限方式相同的方式，但加上负号。
例如，如果最小的枚举量为`−6`，而比它小的、最大的`2`的幂是`−8`（加上负号），因此下限为`−7`。

## 指针和自由存储空间

指针是一个变量，其存储的是**值的地址**，而不是值本身。在讨论指针之前，我们先看一看如何找到常规变量的地址。
只需对变量应用**地址运算符**（`&`），就可以获得它的位置；例如，如果`home`是一个变量，则`&home`是它的地址。
下面的程序演示了这个运算符的用法。

```cpp copy filename="address.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int donuts = 6;
  double cups = 4.5;

  cout << "donuts value = " << donuts;
  cout << " and donuts address = " << &donuts << endl;

  cout << "cups value = " << cups;
  cout << " and cups address = " << &cups << endl;
  return 0;
}
```

下面是该程序在某个系统上的输出：

```bash
donuts value = 6 and donuts address = 0x7fffffffe04c
cups value = 4.5 and cups address = 0x7fffffffe050
```

显示地址时，该实现的`cout`使用十六进制表示法，因为这是常用于描述内存的表示法（有些实现可能使用十进制表示法）。
在该实现中，`donuts`的存储位置比`cups`要低。两个地址的差为 4。

> 有些系统可能先存储`cups`，再存储`donuts`，这样两个地址值的差将为 8 个字节

面向对象编程与传统的过程性编程的区别在于，`OOP`强调的是在运行阶段（而不是编译阶段）进行决策。
运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。运行阶段决策就好比度假时，
选择参观哪些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。

处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—**指针**用于存储值的地址。
因此，指针名表示的是地址。`*`运算符被称为间接值（_indirect velue_）或**解引用**（_dereferencing_）运算符，
将其应用于指针，可以得到该地址处存储的值（这和乘法使用的符号相同；`C++`根据上下文来确定所指的是乘法还是解除引用）。
例如，假设`manly`是一个指针，则`manly`表示的是一个地址，而`*manly`表示存储在该地址处的值。
`*manly`与常规`int`变量等效。下面程序演示了如何声明指针。

```cpp copy filename="pointer.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int updates = 6;           // declare a variable
  int *p_updates = &updates; // assign addresses of int to pointer

  cout << "Values: updates = " << updates;
  cout << ", *p_updates = " << *p_updates << endl;

  cout << "Addresses: &updates = " << &updates;
  cout << ", p_updates = " << p_updates << endl;

  *p_updates = *p_updates + 1;
  cout << "Now updates = " << updates << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
Values: updates = 6, *p_updates = 6
Addresses: &updates = 0x7fffffffe04c, p_updates = 0x7fffffffe04c
Now updates = 7
```

从中可知，`int`变量`updates`和指针变量`p_updates`只不过是同一枚硬币的两面。
变量`updates`表示值，并使用`&`运算符来获得地址；而变量`p_updates`表示地址，并使用`*`运算符来获得值。
由于`p_updates`指向`updates`，因此`*p_updates`和`updates`完全等价。
可以像使用`int`变量那样使用`*p_updates`。甚至可以将值赋给`*p_updates`。这样做将修改指向的值，即`updates`。

![img](https://files.catbox.moe/yjji3r.png)

### 声明和初始化指针

指针声明必须指定指针指向的数据的类型。

例如，前一个示例包含这样的声明：

```cpp
int *p_updates;
```

这表明，`*p_updates`的类型为`int`。由于`*`运算符被用于指针，因此`p_updates`变量本身必须是指针。
我们说`p_updates`指向`int`类型，我们还说`p_updates`的类型是指向`int`的指针，或`int*`。
可以这样说，`p_updates`是指针（地址），而`*p_updates`是`int`，而不是指针。

![img](https://files.catbox.moe/sj0g08.png)

顺便说一句，`*`运算符两边的空格是可选的。传统上，C 程序员使用这种格式：

```cpp
int *ptr;
```

这强调`*ptr`是一个 int 类型的值。而很多 C++程序员使用这种格式：

```cpp
int* ptr;
```

这强调的是：`int*`是一种类型—指向`int`的指针。在哪里添加空格对于编译器来说没有任何区别。

但要知道的是，下面的声明创建一个指针（`p1`）和一个`int`变量（`p2`）:

```cpp
int* p1, p2;
```

> 对每个指针变量名，都需要使用一个`*`。

可以用同样的句法来声明指向其他类型的指针：

```cpp
double* tax_ptr;
char* str;
```

由于已将`tax_ptr`声明为一个指向`double`的指针，因此编译器知道`*tax_ptr`是一个`double`类型的值。
也就是说，它知道`*tax_ptr`是一个以浮点格式存储的值，这个值（在大多数系统上）占据 8 个字节。
指针变量不仅仅是指针，而且是指向特定类型的指针。`tax_ptr`的类型是指向`double`的指针（或`double *`类型），
`str`是指向`char`的指针类型（或`char *`）。尽管它们都是指针，却是不同类型的指针。
和数组一样，指针都是基于其他类型的。

虽然`tax_ptr`和`str`指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的。
也就是说，`char`的地址与`double`的地址的长度相同，这就好比`1016`可能是超市的街道地址，
而`1024`可以是小村庄的街道地址一样。地址的长度或值既不能指示关于变量的长度或类型的任何信息，
也不能指示该地址上有什么建筑物。一般来说，地址需要 2 个还是 4 个字节，取决于计算机系统
（有些系统可能需要更大的地址，系统可以针对不同的类型使用不同长度的地址）。

可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。
也就是说，下面的语句将`pt`（而不是`*pt`）的值设置为`&higgens`：

```cpp
int higgens = 5;
int *ptr = &higgens;
```

下面的程序演示了这些：

```cpp copy filename="int_ptr.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int higgens = 5;
  int *ptr = &higgens;

  cout << "Variable of higgens = " << higgens
       << "; Address of higgens = " << &higgens << endl;
  cout << "Value of *ptr = " << *ptr
       << "; Value of ptr = " << ptr << endl;
  return 0;
}
```

下面是该程序的示例输出：

```bash
Variable of higgens = 5; Address of higgens = 0x7fffffffe04c
Value of *ptr = 5; Value of ptr = 0x7fffffffe04c
```

从中可知，程序将`ptr`（而不是`*ptr`）初始化为`higgens`的地址。
在不同的系统上，显示的地址可能不同，显示格式也可能不同。

### 指针的危险

极其重要的一点是：在 C++中创建指针时，计算机将**分配用来存储地址的内存**，但**不会
分配用来存储指针所指向的数据的内存**。为数据提供空间是一个独立的步骤，忽略这一步无疑是自找麻烦，如下所示：

```cpp
long *fellow; // create a pointer-to-long
*fellow = 223333; // place a value never-never land
```

`fellow`确实是一个指针，但它指向哪里呢？上述代码没有将地址赋给`fellow`。
那么`223323`将被放在哪里呢？我们不知道。由于`fellow`没有被初始化，
它可能有任何值。不管值是什么，程序都将它解释为存储`223323`的地址。
如果`fellow`的值碰巧为`1200`，计算机将把数据放在地址`1200`上，即使这恰巧是程序代码的地址。
`fellow`指向的地方很可能并不是所要存储`223323`的地方。
这种错误可能会导致一些最隐匿、最难以跟踪的`bug`。

<Callout type="warning">

一定要在对指针应用解除引用运算符（`*`）之前，将指针初始化为一个**确定的、适当的**地址。这是关于使用指针的金科玉律。

</Callout>

### 指针和数字

指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针与整数是截然不同的类型。
整数是可以执行加、减、除等运算的数字，而指针描述的是位置，将两个地址相乘没有任何意义。
从可以对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单地将整数赋给指针：

```cpp
int *pt;
pt = 0xB80000000;
```

在这里，左边是指向`int`的指针，因此可以把它赋给地址，但右边是一个整数。
`0xB8000000`是老式计算机系统中视频内存的组合段偏移地址，但这条语句并没有告诉程序，这个数字就是一个地址。
在 C99 标准发布之前，C 语言允许这样赋值。但 C++在类型一致方面的要求更严格，编译器将显示一条错误消息，通告类型不匹配。
要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：

```cpp
int *pt;
pt = (int *) 0xB800000000;
```

### 使用 new 来进行内存分配

对指针的工作方式有一定了解后，来看看它如何实现在程序运行时分配内存。
前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，
而指针只是为可以通过名称直接访问的内存提供了一个别名。
指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。
在这种情况下，只能通过指针来访问内存。在 C 语言中，可以用库函数`malloc()`来分配内存；
在 C++中仍然可以这样做，但 C++还有更好的方法—`new`运算符。

在运行阶段为一个`int`值分配**未命名的内存**，并使用指针来访问这个值。这里的关键所在是 C++的`new`运算符。
我们要告诉`new`，**需要为哪种数据类型分配内存**；`new`将找到一个长度正确的内存块，并返回该内存块的地址。
程序员的责任是将该地址赋给一个指针。下面是一个这样的示例:

```cpp
int *pn = new int;
```

`new int`告诉程序，需要适合存储`int`的内存。`new`运算符根据类型来确定需要多少字节的内存。
然后，它找到这样的内存，并返回其地址。接下来，将地址赋给`pn`，`pn`是被声明为指向`int`的指针。
现在，pn 是`地址`，而`*pn`是存储在那里的值。将这种方法与将变量的地址赋给指针进行比较：

```cpp
int higgens;
int* pt = &higgens;
```

在这两种情况（`pn`和`pt`）下，都是将一个`int`变量的地址赋给了指针。
在第二种情况下，可以通过名称`higgens`来访问该`int`，在第一种情况下，则**只能通过该指针进行访问**。
这引出了一个问题：`pn`指向的内存没有名称，如何称呼它呢？我们说`pn`指向一个数据对象，
这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。
术语“数据对象”比“变量”更通用，它指的是**为数据项分配的内存块**。
因此，变量也是数据对象，但`pn`指向的内存不是变量。
乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。

为一个数据对象（可以是结构体，也可以是基本类型）获得并指定分配内存的通用格式如下：

```cpp
typeName* pointer_name = new typeName;
```

需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。
当然，如果已经声明了相应类型的指针，则可以使用该指针，而不用再声明一个新的指针。

```cpp copy filename="use_new.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  int nights = 1001;
  int *pt = new int;
  *pt = 1001;

  cout << "nights value = " << nights
       << ": location = " << &nights << endl;

  cout << "int ";
  cout << "value = " << *pt << ": location = " << pt << endl;

  double *pd = new double;
  *pd = 10000001.0;

  cout << "double ";
  cout << "value = " << *pd << ": location = " << pd << endl;
  cout << "location of pointer pd: " << &pd << endl;
  cout << "size of pt = " << sizeof(pt);
  cout << ": size of *pt = " << sizeof(*pt) << endl;
  cout << "size of pd = " << sizeof(pd);
  cout << ": size of *pd = " << sizeof(*pd) << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
nights value = 1001: location = 0x7fffffffe044
int value = 1001: location = 0x55555556aeb0
double value = 1e+07: location = 0x55555556b2e0
location of pointer pd: 0x7fffffffe048
size of pt = 8: size of *pt = 4
size of pd = 8: size of *pd = 8
```

该程序使用`new`分别为`int`类型和`double`类型的数据对象分配内存。这是在程序运行时进行的。
指针`pt`和`pd`指向这两个数据对象，如果没有它们，将无法访问这些内存单元。
有了这两个指针，就可以像使用变量那样使用`*pt`和`*pd`了。将值赋给`*pt`和`*pd`，
从而将这些值赋给新的数据对象。同样，可以通过打印`*pt`和`*pd`来显示这些值。

该程序还指出了必须声明指针所指向的类型的原因之一。地址本身只指出了对象存储地址的开始，而没有指出其类型（使用的字节数）。
从这两个值的地址可以知道，它们都只是数字，并没有提供类型或长度信息。另外，指向`int`的指针的长度与指向`double`的指针相同。
它们都是地址，但由于`use_new.cpp`声明了指针的类型，因此程序知道`*pd`是 8 个字节的`double`值，
`*pt`是 4 个字节的`int`值。`use_new.cpp`打印`*pd`的值时，`cout`知道要读取多少字节以及如何解释它们。

对于指针，需要指出的另一点是，`new`分配的内存块通常与常规变量声明分配的内存块不同。
变量`nights`和`pd`的值都存储在被称为栈（_stack_）的内存区域中，而`new`从被称为堆（_heap_）
或自由存储区（_free store_）的内存区域分配内存。

### 使用 delete 释放内存

当需要内存时，可以使用`new`来请求，这只是 C++内存管理数据包中有魅力的一个方面。
另一个方面是`delete`运算符，它使得在使用完内存后，能够将其归还给内存池，
这是通向最有效地使用内存的关键一步。归还或释放（_free_）的内存可供程序的其他部分使用。
使用`delete`时，后面要加上指向内存块的指针（这些内存块最初是用`new`分配的）：

```cpp
int *ps = new int;
...
delete ps;
```

这将释放`ps`指向的内存，但不会删除指针`ps`本身。例如，可以将`ps`重新指向另一个新分配的内存块。
一定要配对地使用`new`和`delete`；否则将发生**内存泄漏**（_memory leak_），
也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。

**不要尝试释放已经释放的内存块**，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。
另外，不能使用`delete`来释放声明变量所获得的内存：

```cpp
int* ps = new int; // ok
delete ps; // ok
delete ps; // not ok
int jugs = 5; // ok
int *pi = &jugs; // ok
delete pi; // not allowed, memory not allocated by new
```

<Callout type="warning">

只能用`delete`来释放使用`new`分配的内存。然而，对空指针使用`delete`是安全的。

</Callout>

注意，使用`delete`的关键在于，将它用于`new`分配的内存。这并不意味着要使用用于`new`的指针，而是用于`new`的地址：

```cpp
int* ps = new int; // allocate memory
int* pq = ps; // set second pointer to same block
delete pq; // delete second pointer
```

一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。
但稍后会看到，对于返回指针的函数，使用另一个指针确实有道理。

### 使用 new 来创建动态内存数组

如果程序只需要一个值，则可能会声明一个简单变量，因为对于管理一个小型数据对象来说，
这样做比使用`new`和指针更简单，尽管给人留下的印象不那么深刻。
通常，对于大型数据（如数组、字符串和结构体），应使用`new`，这正是`new`的用武之地。
例如，假设要编写一个程序，它是否需要数组取决于运行时用户提供的信息。
如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。
不管程序最终是否使用数组，数组都在那里，它占用了内存。
在编译时给数组分配内存被称为**静态联编**（_static binding_），
意味着数组是在编译时加入到程序中的。但使用`new`时，如果在运行阶段需要数组，则创建它；
如果不需要，则不创建。还可以在程序运行时选择数组的长度。
这被称为**动态联编**（_dynamic binding_），意味着数组是在程序运行时创建的。
这种数组叫作**动态数组**（_dynamic array_）。
使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。

#### 使用 new 创建动态数组

在 C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉`new`即可。
必须在类型名后加上方括号，其中包含元素数目。例如，要创建一个包含 10 个`int`元素的数组，可以这样做：

```cpp
int* psome = new int[10];
```

`new`运算符返回第一个元素的地址。。在这个例子中，该地址被赋给指针`psome`。

当程序使用完`new`分配的内存块时，应使用`delete`释放它们。
然而，对于使用`new`创建的数组，应使用另一种格式的`delete`来释放：

```cpp
delete [] psome; // free a dynamic array
```

方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。
请注意`delete`和指针之间的方括号。如果使用`new`时，不带方括号，则使用`delete`时，也不应带方括号。
如果使用`new`时带方括号，则使用`delete`时也应带方括号。C++的早期版本无法识别方括号表示法。
然而，对于`ANSI/ISO`标准来说，`new`与`delete`的格式不匹配导致的后果是不确定的，
这意味着程序员不能依赖于某种特定的行为。下面是一个例子：

```cpp
int* pt = new int;
short* ps = new short[500];
delete []pt; // effect is undefined, don't do it
delete ps; // effect is undefined, don't do it
```

总之，使用`new`和`delete`时，应遵守以下规则。

- 不要使用`delete`来释放不是`new`分配的内存
- 不要使用`delete`释放同一个内存块两次
- 如果使用`new []`为数组分配内存，则应使用`delete []`来释放。
- 如果使用`new []`为一个实体分配内存，则应使用`delete`（没有方括号）来释放。
- 对空指针应用 `delete` 是安全的。

现在我们回过头来讨论动态数组。`psome`是指向一个`int`（数组第一个元素）的指针。
责任是跟踪内存块中的元素个数。也就是说，由于编译器不能对`psome`是指向 10 个整数中的第 1 个这种情况进行跟踪，
因此编写程序时，必须让程序跟踪元素的数目。

实际上，程序确实跟踪了分配的内存量，以便以后使用`delete []`运算符时能够正确地释放这些内存。
但这种信息不是公用的，例如，不能使用`sizeof`运算符来**确定动态分配的数组包含的字节数**。

为数组分配内存的通用格式如下：

```cpp
type_name* pointer_name = new type_name[num_elements];
```

使用`new`运算符可以确保内存块足以存储`num_elements`个类型为`type_name`的元素，
而`pointer_name`将指向第 1 个元素。下面将会看到，可以以使用数组名的方式来使用`pointer_name`。

#### 使用动态数组

现在从实际角度考虑这个问题。如何访问其中的元素呢？第一个元素不成问题。
由于`psome`指向数组的第 1 个元素，因此`*psome`是第 1 个元素的值。
这样，还有 9 个元素。如果没有使用过 C 语言，下面这种最简单的方法可能会令您大吃一惊：
只要把指针当作数组名使用即可。也就是说，对于第 1 个元素，可以使用`psome[0]`，而不是`*psome`；
对于第 2 个元素，可以使用`psome[1]`，依此类推。这样，使用指针来访问动态数组就非常简单了，
虽然还不知道为何这种方法管用。可以这样做的原因是，C 和 C++内部都使用指针来处理数组,数组和指针基本等价。

```cpp
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  double *p3 = new double[3];
  p3[0] = 0.2;
  p3[1] = 0.5;
  p3[2] = 0.8;
  cout << "p3[1] is " << p3[1] << ".\n";
  p3 = p3 + 1;
  cout << "now p3[0] is " << p3[0] << " and ";
  cout << "p3[1] is " << p3[1] << ".\n";
  p3 = p3 - 1;
  delete[] p3;
  return 0;
}
```

下面是该程序的输出：

```bash
p3[1] is 0.5.
now p3[0] is 0.5 and p3[1] is 0.8.
```

从中可知，`arraynew.cpp`将指针`p3`当作数组名来使用，`p3[0]`为第 1 个元素，依次类推。
下面的代码行指出了数组名和指针之间的根本差别：

```cpp
p3 = p3 + 1; // okay for pointers, wrong for array names
```

不能修改数组名的值。但指针是变量，因此可以修改它的值。请注意将`p3`加`1`的效果。
表达式`p3[0]`现在指的是数组的第`2`个值。因此，将`p3`
加`1`导致它指向第`2`个元素而不是第`1`个。将它减`1`后，指针将指向原来的值，
这样程序便可以给`delete[]`提供正确的地址。

## 指针、数组和指针计算

内部处理数组的方式。首先，我们来看一看算术。将整数变量加 1 后，其值将增加 1；
但将指针变量加 1 后，增加的量等于它指向的类型的字节数。将指向`double`的指针加 1 后，
如果系统对`double`使用 8 个字节存储，则数值将增加 8；将指向`short`的指针加 1 后，
如果系统对`short`使用 2 个字节存储，则指针值将增加 2。
下面的程序了说明了这一点，它还说明了另一点：C++将数组名解释为地址。

```cpp copy filename="addpntrs.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  double wages[3] = {1000.0, 2000.0, 3000.0};
  short stacks[3] = {3, 2, 1};

  // here are two ways to get the address of an array
  double *pw = wages;
  short *ps = &stacks[0];

  // with array elements
  cout << "pw = " << pw << ", *pw = " << *pw << endl;
  pw = pw + 1;
  cout << "add 1 to the pw pointer:\n";
  cout << "pw = " << pw << ", *pw = " << *pw << endl
       << endl;
  cout << "ps = " << ps << ", *ps = " << *ps << endl;
  ps = ps + 1;
  cout << "add 1 to the ps pointer:\n";
  cout << "ps = " << ps << ", *ps = " << *ps << endl
       << endl;
  cout << "access two elements with array notation:" << endl;
  cout << "stacks[0] = " << stacks[0] << ", stacks[1] = " << stacks[1] << endl;
  cout << "access two elements with pointer notation:" << endl;
  cout << "*stacks = " << *stacks << ", *(stacks + 1) = " << *(stacks + 1) << endl;

  cout << sizeof(wages) << " = size of wages array" << endl;
  cout << sizeof(pw) << " = size of pw pointer" << endl;
  return 0;
}
```

下面是该程序的输出：

```bash
pw = 0x7fffffffe040, *pw = 1000
add 1 to the pw pointer:
pw = 0x7fffffffe048, *pw = 2000

ps = 0x7fffffffe03a, *ps = 3
add 1 to the ps pointer:
ps = 0x7fffffffe03c, *ps = 2

access two elements with array notation:
stacks[0] = 3, stacks[1] = 2
access two elements with pointer notation:
*stacks = 3, *(stacks + 1) = 2
24 = size of wages array
8 = size of pw pointer
```

### 程序说明

在多数情况下，C++将数组名解释为数组第 1 个元素的地址。因此，下面的语句将`pw`声明为指向`double`类型的指针，
然后将它初始化为`wages—wages`数组中第 1 个元素的地址：

```cpp
double* pw = wages;
```

和所有数组一样，`wages`也存在下面的等式：

```cpp
wages = &wages[0] = address of first element of array
```

为表明情况确实如此，该程序在表达式`&stacks[0]`中显式地使用地址运算符来将`ps`指针初始化为`stacks`数组的第 1 个元素。

接下来，程序查看`pw`和`*pw`的值。前者是地址，后者是存储在该地址中的值。
由于`pw`指向第 1 个元素，因此`*pw`显示的值为第 1 个元素的值，即 10000。
接着，程序将`pw`加 1。正如前面指出的，这样**数字地址值将增加 8**，这使得`pw`的值为第 2 个元素的地址。

![img](https://files.catbox.moe/ka8chx.png)

此后，程序对`ps`执行相同的操作。这一次由于`ps`指向的是`short`类型，而`short`占用 2 个字节，
因此将指针加 1 时，其值将增加 2。结果是，指针也指向数组中下一个元素。

```cpp
arrayname[i] = *(arrayname + 1);
```

因此，在很多情况下，可以相同的方式使用指针名和数组名。
对于它们，可以使用数组方括号表示法，也可以使用解除引用运算符（`*`）。
在多数表达式中，它们都表示地址。区别之一是，可以修改指针的值，而数组名是常量：

```cpp
pointername = poitername + 1; // valid
arrayname = arrayname + 1; // not valid
```

另一个区别是，对数组应用`sizeof`运算符得到的是数组的长度，
而对指针应用`sizeof`得到的是指针的长度，即使指针指向的是一个数组。

### 指针小结

#### 声明指针

要声明指向特定类型的指针，请使用下面的格式：

```cpp
typeName* pointerName;
```

#### 给指针赋值

应将内存地址赋给指针。可以对变量名应用`&`运算符，来获得被命名的内存的地址，`new`运算符返回未命名的内存的地址。

```cpp
double* pn = &a;
double* ps = new double;
```

#### 对指针解引用

对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（`*`）来解除引用。
因此，如果像上面的例子中那样，`pn`是指向`bubble`的指针，则`*pn`是指向的值。

```cpp
int a = 10;
int* pn = &a;
cout << *a; // 10
```

#### 区分指针和指针所指向的值

如果`pt`是指向`int`的指针，则`*pt`不是指向`int`的指针，而是完全等同于一个`int`类型的变量。`pt`才是指针。

```cpp
int* pt = new int; // assigns an address to the pointer ptr
*pt = 5;  // store the value 5 at that address
```

#### 数组名

在多数情况下，C++将数组名视为数组的第一个元素的地址。

一种例外情况是，将`sizeof`运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。

#### 指针算数

C++允许将指针和整数相加。加 1 的结果等于原来的地址值加上指向的对象占用的总字节数。
还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，
**仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义**；
这将得到两个元素的间隔。

```cpp
int tacos[10] = {5, 2, 8, 4, 1, 2, 3, 4, 6, 8};
int* pt = tacos;
pt = pt + 1;
int *pe = &tacos[9];
pe = pe - 1;
int diff = pe - pt;
```

#### 数组的动态联编和静态联编

使用数组声明来创建数组时，将采用**静态联编**，即**数组的长度在编译时**设置：

```cpp
int tacos[10]; // static binding, size fixed at compile time
```

使用`new[]`运算符创建数组时，将采用**动态联编**（动态数组），即**在运行时为数组分配空间**，
其长度也将在运行时设置。使用完这种数组后，应使用`delete[]`释放其占用的内存：

```cpp
int size;
cin >> size;
int *pz = new int[size];
...
delete[] pz;
```

#### 数组表示法和指针表示法

使用方括号数组表示法等同于对指针解除引用：

```cpp
tacos[0] means *tacos means the value at address tacos
tacos[3] means *(tacos + 3) means the value at address tacos + 3
```

### 指针和字符串

数组和指针的特殊关系可以扩展到 C-风格字符串。请看下面的代码：

```cpp
char flower[10] = "rose";
cout << flower << "s are red" << endl;
```

数组名是第一个元素的地址，因此`cout`语句中的`flower`是包含字符`r`的`char`元素的地址。
`cout`对象认为`char`的地址是字符串的地址，因此它打印该地址处的字符，然后继续打印后面的字符，直到遇到空字符（`\0`）为止。
总之，如果给`cout`提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。

这里的关键不在于`flower`是数组名，而在于`flower`是一个`char`的地址。
这意味着可以将指向`char`的指针变量作为`cout`的参数，因为它也是`char`的地址。
当然，该指针指向字符串的开头，稍后将核实这一点。

前面的`cout`语句中最后一部分的情况如何呢？如果`flower`是字符串第一个字符的地址，
则表达式“s are red\n”是什么呢？为了与`cout`对字符串输出的处理保持一致，这个用引号括起的字符串也应当是一个地址。
在 C++中，用引号括起的字符串像数组名一样，也是第一个元素的地址。上述代码不会将整个字符串发送给`cout`，
而只是发送该字符串的地址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针所描述的字符串，
处理的方式是一样的，都将传递它们的地址。与逐个传递字符串中的所有字符相比，这样做的工作量确实要少。

<Callout type="info">

在`cout`和多数 C++表达式中，`char`数组名、`char`指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。

</Callout>

```cpp copy filename="ptrctr.cpp"
#include <cstring>
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  char animal[20] = "bear";
  const char *bird = "wren";
  char *ps;

  cout << animal << " and ";
  cout << bird << "\n";

  cout << "Enter a kind of animal: ";
  cin >> animal;

  ps = animal;
  cout << ps << "!\n";
  cout << "Before using strcpy():\n";
  cout << animal << " at " << (int *)animal << endl;
  cout << ps << " at " << (int *)ps << endl;

  ps = new char[strlen(animal) + 1];
  strcpy(ps, animal);
  cout << "After using strcpy():\n";
  cout << animal << " at " << (int *)animal << endl;
  cout << ps << " at " << (int *)ps << endl;
  delete[] ps;
  return 0;
}
```

下面是该程序的运行情况：

```bash
bear and wren
Enter a kind of animal: fox
fox!
Before using strcpy():
fox at 0x7fffffffe050
fox at 0x7fffffffe050
After using strcpy():
fox at 0x7fffffffe050
fox at 0x55555556b6d0
```

程序创建了一个`char`数组（`animal`）和两个指向`char`的指针变量（`bird`和`ps`）。
该程序首先将`animal`数组初始化为字符串`“bear”`，就像初始化数组一样。
然后，程序执行了一些新的操作，将`char`指针初始化为指向一个字符串：

```cpp
const char* bird = "wren";
```

<Callout type="info">

记住，“wren”实际表示的是字符串的地址，因此这条语句将`“wren”`的地址赋给了`bird`指针。
这意味着可以像使用字符串`“wren”`那样使用指针`bird`，如下面的示例所示：

```cpp
cout << "A concerned " << bird << " speaks\n";
```

</Callout>

字符串字面值是常量，这就是为什么代码在声明中使用关键字`const`的原因。
以这种方式使用`const`意味着可以用`bird`来访问字符串，但不能修改它。

接下来，程序说明了这样一点，即对于`cout`来说，使用数组名`animal`和指针`bird`是一样的。
毕竟，它们都是字符串的地址，`cout`将显示存储在这两个地址上的两个字符串（`“bear”`和`“wren”`）。

<Callout type="warning">

试图将信息读入`ps`指向的位置将更糟。由于`ps`没有被初始化，因此并不知道信息将被存储在哪里，这甚至可能改写内存中的信息。
幸运的是，要避免这种问题很容易—只要使用足够大的`char`数组来接收输入即可。
**请不要使用字符串常量或未被初始化的指针来接收输入**。为避免这些问题，也可以使用`std::string`对象，而不是数组。

</Callout>

<Callout type="info">

在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用`new`初始化过的指针。

</Callout>

### 使用`new`创建动态结构体

在运行时创建数组优于在编译时创建数组，对于结构体也是如此。
需要在程序运行时为结构分配所需的空间，这也可以使用`new`运算符来完成。
通过使用`new`，可以创建动态结构。同样，**“动态”意味着内存是在运行时，而不是编译时分配的**。
由于类与结构体非常相似，因此本节介绍的有关结构体的技术也适用于类。

将`new`用于结构由两步组成：创建结构和访问其成员。要创建结构体，需要同时使用结构体类型和`new`。
例如，要创建一个未命名的`inflatable`类型，并将其地址赋给一个指针，可以这样做：

```cpp
inflatable* ps = new inflatable;
```

这将把足以存储`inflatable`结构的一块可用内存的地址赋给`ps`。这种句法和 C++的内置类型完全相同。

比较棘手的一步是访问成员。创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构体没有名称，只是知道它的地址。
C++专门为这种情况提供了一个运算符：箭头成员运算符（`−>`）。该运算符由连字符和大于号组成，
可用于指向结构的指针，就像点运算符可用于结构名一样。例如，如果`ps`指向一个`inflatable`结构，
则`ps−>price`是被指向的结构的`price`成员。

![img](https://files.catbox.moe/fx5qoj.png)

<Callout type="info">

有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。
规则非常简单。如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符。

</Callout>

另一种访问结构体成员的方法是，如果`ps`是指向结构体的指针，则`*ps`就是被指向的值—结构本身。
由于`*ps`是一个结构，因此`(*ps).price`是该结构的`price`成员。C++的运算符优先规则要求使用括号。

```cpp copy filename="newstrct.cpp"
#include <iostream>
struct inflatable
{
  char name[20];
  float volume;
  double price;
};
int main(int argc, char const *argv[])
{
  using namespace std;
  inflatable *ps = new inflatable; // allocate memory for inflatable
  cout << "Enter name of inflatable item: ";
  cin.getline(ps->name, 20);
  cout << "Enter volume in cubic feet: ";
  cin >> (*ps).volume;
  cout << "Enter price: $";
  cin >> ps->price;
  cout << "Name: " << (*ps).name << endl;
  cout << "Volume: " << ps->volume << " cube feet\n";
  cout << "Price: $" << ps->price << endl;
  delete ps;
  return 0;
}
```

以下是该程序的输出：

```bash
Enter name of inflatable item: Fabulous Frodo
Enter volume in cubic feet: 1.4
Enter price: $27.99
Name: Fabulous Frodo
Volume: 1.4 cube feet
Price: $27.99
```

#### 一个使用`new`和`delete`的示例

假设程序要读取`100`个字符串，其中最大的字符串包含`79`个字符，而大多数字符串都短得多。
如果用`char`数组来存储这些字符串，则需要`1000`个数组，其中每个数组的长度为`80`个字符。
这总共需要`80000`个字节，而其中的很多内存没有被使用。
另一种方法是，创建一个数组，它包含`1000`个指向 char 的指针，然后使用`new`根据每个字符串的需要分配相应数量的内存。
这将节省几万个字节。是根据输入来分配内存，而不是为每个字符串使用一个大型数组。
另外，还可以使用`new`根据需要的指针数量来分配空间。
就目前而言，这有点不切实际，即使是使用`1000`个指针的数组也是这样。
另外，为演示`delete`是如何工作的，该程序还用它来释放内存以便能够重新使用。

```cpp copy filename="delete.cpp"
#include <cstring>
#include <iostream>

using namespace std;

char *getname(void);

int main(int argc, char const *argv[])
{
  char *name;

  name = getname();
  cout << name << " at " << (int *)name << endl;
  delete[] name;

  name = getname();
  cout << name << " at " << (int *)name << endl;
  delete[] name;

  return 0;
}

char *getname()
{
  char temp[80];
  cout << "Enter last name: ";
  cin >> temp;
  char *pn = new char[strlen(temp) + 1];
  strcpy(pn, temp);

  return pn;
}
```

下面是该程序的运行情况：

```bash
Enter last name: Frededumpkin
Frededumpkin at 0x55555556b6d0
Enter last name: Pook
Pook at 0x55555556b6d0
```

#### 程序说明

来看一下函数`getname()`。它使用`cin`将输入的单词放到`temp`数组中，然后使用`new`分配新内存，以存储该单词。
程序需要`strle(temp)+ 1`个字符（包括空字符）来存储该字符串，因此将这个值提供给`new`。
获得空间后，`getname()`使用标准库函数`strcpy()`将 temp 中的字符串复制到新的内存块中。
该函数并不检查内存块是否能够容纳字符串，但`getname()`通过使用`new`请求合适的字节数来完成了这样的工作。
最后，函数返回`pn`，这是字符串副本的地址。

在`main()`中，返回值（地址）被赋给指针`name`。该指针是在`main()`中定义的，但它指向`getname()`函数中分配的内存块。然后，程序打印
该字符串及其地址。

接下来，在释放`name`指向的内存块后，`main()`再次调用`getname()`。
C++不保证新释放的内存就是下一次使用`new`时选择的内存。

### 自动存储、静态存储和动态存储

根据用于分配内存的方法，C++有 3 种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。
在存在时间的长短方面，以这 3 种方式分配的数据对象各不相同。

#### 自动存储

在函数内部定义的常规变量使用自动存储空间，被称为**自动变量**（_automatic variable_），
这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。例如，`temp`数组仅当`getname()`函数活动时存在。
当程序控制权回到`main()`时，`temp`使用的内存将自动被释放。如果`getname()`返回 temp 的地址，
则`main()`中的`name`指针指向的内存将很快得到重新使用。这就是在`getname()`中使用`new`的原因之一。

实际上，**自动变量是一个局部变量**，其作用域为包含它的代码块。
代码块是被包含在花括号中的一段代码。到目前为止，我们使用的所有代码块都是整个函数。
然而，在下一章将会看到，函数内也可以有代码块。
如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。

自动变量通常存储在**栈**中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，
将按相反的顺序释放这些变量，这被称为后进先出（_LIFO_）。
因此，在程序执行过程中，栈将不断地增大和缩小。

#### 静态存储

静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：
一种是在函数外面定义它；另一种是在声明变量时使用关键字`static`：

```cpp
static double fee = 56.50;
```

自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。
变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。

#### 动态存储

`new`和`delete`运算符提供了一种比自动变量和静态变量更灵活的方法。
它们管理了一个内存池，这在 C++中被称为**自由存储空间**（_free store_）或**堆**（_heap_）。
该内存池同用于静态变量和自动变量的内存是分开的。
`new`和`delete`能够在一个函数中分配内存，而在另一个函数中释放它。
因此，**数据的生命周期不完全受程序或函数的生存时间控制**。
与使用常规变量相比，使用`new`和`delete`让程序员对程序如何使用内存有更大的控制权。
然而，内存管理也更复杂了。
在栈中，自动添加和删除机制使得占用的内存总是连续的，但`new`和`delete`的相互影响可能导致占用的自由存储区不连续，
这使得跟踪新分配内存的位置更困难。

<Callout type="error">

如果使用`new`运算符在自由存储空间（或堆）上创建变量后，没有调用`delete`，将发生什么情况呢？
如果没有调用`delete`，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，
在自由存储空间上动态分配的变量或结构也将继续存在。
实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。
这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；
这些内存被分配出去，但无法收回。
极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。
另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。
即使是最好的程序员和软件公司，也可能导致内存泄漏。
要避免内存泄漏，最好是养成这样一种习惯，即同时使用`new`和`delete`运算符，在自由存储空间上动态分配内存，
随后便释放它。**C++智能指针有助于自动完成这种任务**。

</Callout>

## 类型组合

本章介绍了数组、结构体和指针。可以各种方式组合它们，下面介绍其中的一些，从结构开始：

```cpp
struct antarctica_years_end
{
  int years;
  // some really interesting data, etc.
};
```

可以创建这种类型的变量：

```cpp
antarctica_years_end s01, s02, s03;
```

然后使用成员运算符访问其成员：

```cpp
s01.year = 1998;
```

可创建指向这种结构体的指针：

```cpp
antarctica_years_end* pa = &s02;
```

将该指针设置为有效地址后，就可使用间接成员运算符来访问成员：

```cpp
pa->year = 1999;
```

可创建结构数组：

```cpp
antarctica_years_end trio[3]; // array of 3 structures
```

然后，可以使用成员运算符访问元素的成员：

```cpp
trio[0].year = 2003;
```

其中`trio`是一个数组，`trio[0]`是一个结构体，而`trio[0].year`是该结构的一个成员。
由于数组名是一个指针，因此也可使用间接成员运算符：

```cpp
(trio + 1)->year = 2004;
```

可创建指针数组：

```cpp
const antarctica_years_end* arps[3] = {&s01, &s02, &s03};
```

既然`arp`是一个指针数组，`arp[1]`就是一个指针，可将间接成员运算符应用于它，以访问成员：

```cpp
cout << arp[1]->year << endl;
```

可创建指向上述数组的指针：

```cpp
const antarctica_years_end** ppa = arp;
```

其中`arp`是一个数组的名称，因此它是第一个元素的地址。
但其第一个元素为指针，因此`ppa`是一个指针，指向一个指向`const antarctica_years_end`的指针。
这种声明很容易容错。例如，可能遗漏`const`，忘记`*`，搞错顺序或结构类型。
下面的示例演示了 C++11 版本的`auto`提供的方便。
编译器知道 arp 的类型，能够正确地推断出`ppb`的类型：

```cpp
auto ppb = arp;
```

在以前，编译器利用它推断的类型来指出声明错误，而现在，可利用它的这种推断能力。

如何使用`ppa`来访问数据呢？由于`ppa`是一个指向结构指针的指针，因此`*ppa`是一个结构指针，可将间接成员运算符应用于它：

```cpp
cout << (*ppa)->year << endl;
cout << (*(ppb+1))->year << endl;
```

由于`ppa`指向`arp`的第一个元素，因此`*ppa`为第一个元素，即`&s01`。
所以，`(*ppa)->year`为`s01`的`year`成员。在第二条语句中，`ppb+1`指向下一个元素`arp[1]`，即`&s02`。
其中的括号必不可少，这样才能正确地结合。例如，`*ppa->year`试图将运算符`*`应用于`ppa->year`，
这将导致错误，因为成员`year`不是指针。

```cpp copy filename="mixtypes.cpp"
#include <iostream>

struct antarctica_years_endpoint
{
  int year;
};

int main(int argc, char const *argv[])
{
  antarctica_years_endpoint s01, s02, s03;
  s01.year = 1998;
  antarctica_years_endpoint *pa = &s02;
  pa->year = 1999;
  antarctica_years_endpoint trio[3];
  trio[0].year = 2003;
  std::cout << trio->year << std::endl;
  antarctica_years_endpoint *arp[3] = {&s01, &s02, &s03};
  std::cout << arp[1]->year << std::endl;
  antarctica_years_endpoint **ppa = arp;
  auto ppb = arp;
  std::cout << (*ppa)->year << std::endl;
  std::cout << (*(ppb + 1))->year << std::endl;
  return 0;
}
```

该程序的输出如下：

```bash
2003
1999
1998
1999
```

## 数组的替代品

### 模板类`vector`

模板类`vector`类似于`string`类，也是一种动态数组。
您可以在运行阶段设置`vector`对象的长度，可在末尾附加新数据，还可在中间插入新数据。
基本上，它是使用`new`创建动态数组的替代品。实际上，`vector`类确实使用`new`和`delete`来管理内存，但这种工作是自动完成的。

这里不深入探讨模板类意味着什么，而只介绍一些基本的实用知识。

1. 要使用`vector`对象，必须包含头文件`vector`。
1. `vector`包含在名称空间`std`中，因此可使用`using`编译指令、`using`声明或`std::vector`。
1. 模板使用不同的语法来指出它存储的数据类型。
1. `vector`类使用不同的语法来指定元素数。

下面是一些示例：

```cpp
#include <vector>
using namespace std;
vector<int> vi;
int n;
cin >> n;
vector<double> vd(n);
```

其中，`vi`是一个`vector<int>`对象，`vd`是一个`vector<double>`对象。
由于`vector`对象在插入或添加值时自动调整长度，因此可以将`vi`的初始长度设置为零。
但要调整长度，需要使用`vector`包中的各种方法。

一般而言，下面的声明创建一个名为`vt`的`vector`对象，它可存储`n_elem`个类型为`typeName`的元素：

```cpp
vector<typeName> vt(n_elem);
```

其中参数`n_elem`可以是整型常量，**也可以是整型变量**。

### 模板类 array

`vector`类的功能比数组强大，但付出的代价是效率稍低。
如果需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便和安全。
有鉴于此，C++11 新增了模板类`array`，它也位于名称空间`std`中。
与数组一样，`array`对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。
要创建`array`对象，需要包含头文件`array`。`array`对象的创建语法与`vector`稍有不同：

```cpp
#include <array>
using namespace std;
array<int, 5> ai;
array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
```

推而广之，下面的声明创建一个名为`arr`的`array`对象，它包含`n_elem`个类型为`typename`的元素：

```cpp
array<typename, n_elem> arr;
```

与创建`vector`对象不同的是，**`n_elem`不能是变量**。

### 比较数组、`vector`对象和`array`对象

```cpp copy filename="choices.cpp"
#include <array>
#include <iostream>
#include <vector>

int main(int argc, char const *argv[])
{
  using namespace std;
  // C, origin C++
  double a1[4] = {1.2, 2.4, 3.6, 4.8};
  // C++98 STL
  vector<double> a2(4); // create vector with 4 elements
  // no simple way to initialize in C98
  a2[0] = 1.0 / 3.0;
  a2[1] = 1.0 / 5.0;
  a2[2] = 1.0 / 7.0;
  a2[3] = 1.0 / 9.0;
  // C++11 -- create and initialize array object
  array<double, 4> a3 = {3.14, 2.72, 1.62, 1.41};
  array<double, 4> a4;
  a4 = a3;
  // use array notation
  cout << "a1[2]: " << a1[2] << " at " << &a1[2] << endl;
  cout << "a2[2]: " << a2[2] << " at " << &a2[2] << endl;
  cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
  cout << "a4[2]: " << a4[2] << " at " << &a4[2] << endl;
  // misdeed
  a1[-2] = 20.2;
  cout << "a1[-2]: " << a1[-2] << " at " << &a1[-2] << endl;
  cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
  cout << "a4[-2]: " << a4[2] << " at " << &a4[2] << endl;
  return 0;
}
```

下面是该程序的输出示例:

```bash
a1[2]: 3.6 at 0x7fffffffdfe0
a2[2]: 0.142857 at 0x55555556bec0
a3[2]: 1.62 at 0x7fffffffe000
a4[2]: 1.62 at 0x7fffffffe020
a1[-2]: 20.2 at 0x7fffffffdfc0
a3[2]: 1.62 at 0x7fffffffe000
a4[-2]: 1.62 at 0x7fffffffe020
```

首先，注意到无论是数组、`vector`对象还是`array`对象，都可使用标准数组表示法来访问各个元素。
其次，从地址可知，`array`对象和数组存储在相同的内存区域（即栈）中，
而`vector`对象存储在另一个区域（自由存储区或堆）中。
第三，注意到可以将一个`array`对象赋给另一个`array`对象；而对于数组，必须逐元素复制数据。

接下来，下面一行代码需要特别注意：

```cpp
a1[-2] = 20.2;
```

索引`-2`是什么意思呢？本章前面说过，这将被转换为如下代码：

```cpp
*(a1 - 2) = 20.2;
```

其含义如下：找到`a1`指向的地方，向前移两个`double`元素，并将`20.2`存储到目的地。
也就是说，将信息存储到数组的外面。与 C 语言一样，C++也不检查这种超界错误。
在这个示例中，这个位置位于`array`对象`a3`中。
其他编译器可能将`20.2`放在`a4`中，甚至做出更糟糕的选择。**这表明数组的行为是不安全的**。

> 脑袋没问题的话别这么写

## 编程练习

import IsShowCode from "components/IsShowCode";

1. 编写一个 C++程序，如下述输出示例所示的那样请求并显示信息：

```bash
What is your first name? Betty Sue
What is your last name? Yewe
What letter grade do you deserve? B
What is your age? 22
Name: Yewe, Betty Sue
Grade: C
Age: 22
```

<Callout type="warning">

注意，该程序应该接受的名字包含多个单词。
另外，程序将向下调整成绩，即向上调一个字母。
假设用户请求`A`、`B`或`C`，所以不必担心`D`和`F`之间的空档。

</Callout>

<IsShowCode>

```cpp copy filename="ex4_1.cpp"
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  char first_name[20];
  char last_name[20];
  char grade;
  int age;
  cout << "What is your first name? ";
  cin.getline(first_name, 20);
  cout << "What is your last name? ";
  cin.getline(last_name, 20);
  cout << "What letter grade do you deserve? ";
  cin >> grade;
  cout << "What is your age? ";
  cin >> age;
  cout << "Name: " << last_name << ", " << first_name << endl;
  cout << "Grade: " << char(grade + 1) << endl;
  cout << "Age: " << age << endl;
  return 0;
}
```

</IsShowCode>

2. 修改题目 1， 使用`C++ string`类而不是`char`数组。

<IsShowCode>

```cpp copy filename="ex4_2.cpp"
#include <iostream>
#include <string>

struct Student
{
  std::string first_name;
  std::string last_name;
  char grade;
  int age;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  Student stu;
  cout << "What is your first name? ";
  getline(cin, stu.first_name);
  cout << "What is your last name? ";
  getline(cin, stu.last_name);
  cout << "What letter grade do you deserve? ";
  cin >> stu.grade;
  cout << "What is your age? ";
  cin >> stu.age;

  cout << "Name: " << stu.last_name << ", " << stu.first_name << endl;
  cout << "Grade: " << char(stu.grade + 1) << endl;
  cout << "Age: " << stu.age << endl;
  return 0;
}
```

</IsShowCode>

3. 编写一个程序，它要求用户首先输入其名，然后输入其姓；
   然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。
   请使用`char`数组和头文件`cstring`中的函数。下面是该程序运行时的情形：

```bash
Enter your first name: Flip
Enter your last name: Fleming
Here's the information in a single string: Fleming, Flip
```

<IsShowCode>

```cpp copy filename="ex4_3.cpp"
#include <cstring>
#include <iostream>

int main(int argc, char const *argv[])
{
  using namespace std;
  char first_name[20], last_name[20];
  cout << "Enter your first name: ";
  cin.getline(first_name, 20);
  cout << "Enter your last name: ";
  cin.getline(last_name, 20);
  cout << "Here's the information in a single string: "
       << strcat(strcat(last_name, ", "), first_name);

  return 0;
}
```

</IsShowCode>

4. 编写一个程序，它要求用户首先输入其名，再输入其姓；
   然后程序使用一个逗号和空格将姓和名组合起来，并存储和显示组合结果。
   请使用`string`对象和头文件`string`中的函数。下面是该程序运行时的情形：

```bash
Enter your first name: Flip
Enter your last name: Fleming
Here's the information in a single string: Fleming, Flip
```

<IsShowCode>

```cpp copy filename="ex4_4.cpp"
#include <iostream>
#include <string>

int main(int argc, char const *argv[])
{
  using namespace std;
  string first_name, last_name;
  cout << "Enter your first name: ";
  getline(cin, first_name);
  cout << "Enter your last name: ";
  getline(cin, last_name);
  cout << "Here's the information in a single string: "
       << last_name + ", " + first_name;
  return 0;
}
```

</IsShowCode>

5. 结构`CandyBar`包含 3 个成员。第一个成员存储了糖块的品牌；
   第二个成员存储糖块的重量（可以有小数）；第三个成员存储了糖块的卡路里含量（整数）。
   请编写一个程序，声明这个结构，创建一个名为`snack`的`CandyBar`变量，
   并将其成员分别初始化为`“Mocha Munch”`、`2.3`和`350`。
   初始化应在声明`snack`时进行。最后，程序显示`snack`变量的内容。

<IsShowCode>

```cpp copy filename="ex4_5.cpp"
#include <iostream>
#include <string>

struct CandyBar
{
  std::string band;
  float weight;
  int calorie;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  CandyBar snake = {"Mocha Munch", 2.3, 350};
  cout << "snake band: " << snake.band << endl;
  cout << "snake weight: " << snake.weight << endl;
  cout << "snake calorie: " << snake.calorie << endl;
  return 0;
}
```

</IsShowCode>

6. 结构`CandyBar`包含 3 个成员，如编程练习 5 所示。
   请编写一个程序，创建一个包含`3`个元素的`CandyBar`数组，并将它们初始化为所选择的值，然后显示每个结构的内容。

<IsShowCode>

```cpp copy filename="ex4_6.cpp"
#include <iostream>
#include <string>

struct CandyBar
{
  std::string band;
  float weight;
  int calorie;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  CandyBar snacks[3] = {{"test1", 2.4, 100}, {"test2", 2.5, 11}, {"test3", 2.6, 5}};
  for (size_t i = 0; i < 3; i++)
  {
    cout << "band: " << snacks[i].band << endl;
    cout << "weight: " << snacks[i].weight << endl;
    cout << "calorie: " << snacks[i].calorie << endl
         << endl;
  }

  return 0;
}
```

</IsShowCode>

7. `William Wingate`从事比萨饼分析服务。对于每个披萨饼，他都需要记录下列信息：

- 披萨饼公司的名称，可以有多个单词组成。
- 披萨饼的直径。
- 披萨饼的重量。

请设计一个能够存储这些信息的结构，并编写一个使用这种结构变量的程序。
程序将请求用户输入上述信息，然后显示这些信息。请使用`cin`（或它的方法）和`cout`。

<IsShowCode>

```cpp copy filename="ex4_7.cpp"
#include <iostream>
#include <string>

struct Pizza
{
  std::string company_name;
  int d;
  int weight;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  Pizza pizza;
  cout << "Please input pizza's company name: ";
  getline(cin, pizza.company_name);
  cout << "Please input pizza's d: ";
  cin >> pizza.d;
  cout << "Please input pizza's weight: ";
  cin >> pizza.weight;

  cout << "company name: " << pizza.company_name << endl;
  cout << "weight: " << pizza.weight << endl;
  cout << "d: " << pizza.d << endl;
  return 0;
}
```

</IsShowCode>

8. 完成编程练习 7，但使用 new 来为结构分配内存，而不是声明一个结构变量。
   另外，让程序在请求输入比萨饼公司名称之前输入比萨饼的直径。

<IsShowCode>

```cpp copy filename="ex04_8.cpp"
#include <iostream>
#include <string>

struct Pizza
{
  std::string company_name;
  int d;
  int weight;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  Pizza *pizza = new Pizza;
  cout << "Please input pizza's d: ";
  cin >> pizza->d;
  cin.get();
  cout << "Please input pizza's company name: ";
  getline(cin, pizza->company_name);
  cout << "Please input pizza's weight: ";
  cin >> pizza->weight;

  cout << "company name: " << pizza->company_name << endl;
  cout << "d: " << pizza->d << endl;
  cout << "weight: " << pizza->weight << endl;
  delete pizza;
  return 0;
}
```

</IsShowCode>

9. 完成编程练习 6，但使用 new 来动态分配数组，而不是声明一个包含 3 个元素的`CandyBar`数组。

<IsShowCode>

```cpp copy filename="ex4_9.cpp"
#include <iostream>
#include <string>

struct CandyBar
{
  std::string band;
  float weight;
  int calorie;
};

int main(int argc, char const *argv[])
{
  using namespace std;
  CandyBar *snacks = new CandyBar[3]{
      {"Mocha Munch", 2.3, 350},
      {"Big Rabbit", 5, 300},
      {"Joy Boy", 4.1, 430}
  };
  for (size_t i = 0; i < 3; i++)
  {
    cout << "band: " << snacks[i].band << endl;
    cout << "weight: " << snacks[i].weight << endl;
    cout << "calorie: " << snacks[i].calorie << endl
         << endl;
  }

  delete[] snacks;
  return 0;
}

```

</IsShowCode>
