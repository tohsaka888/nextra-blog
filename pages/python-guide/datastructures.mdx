# 数据结构

## 列表详解

- `list.append(x)`

  - 在列表末尾添加一个元素，相当于`a[len(a):] = [x]`

- `list.extend(iterable)`

  - 用可迭代对象的元素扩展列表。相当于`a[len(a):] = iterable`

- `list.insert(i, x)`

  - 在指定位置插入元素。第一个参数是插入元素的索引，因此，`a.insert(0 ,x)`在列表开头插入一个元素。

- `list.remove(x)`

  - 在列表中删除第一个值为 x 的元素。未找到指定元素时，出发`ValueError`异常。

- `list.pop([i])`

  - 删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，`a.pop()`删除并返回列表的最后一个元素。

- `list.clear()`

  - 删除列表的所有元素，相当于`del a[:]`

- `list.index(x, [, start[, end]])`

  - 返回列表中第一个值为 `x` 的元素的零基索引。未找到指定元素时，触发 `ValueError` 异常。

- `list.count(x)`

  - 返回列表中元素`x`出现的次数。

- `list.sort(*, key=None, reserve=False)`

  - 就地排序列表中的元素。

- `list.reverse()`

  - 反转列表中的元素。

- `list.copy()`
  - 返回列表的浅拷贝。相当于`a[:]`。

## 用列表实现堆栈

使用列表方法实现堆栈非常容易，最后插入的最先取出（“后进先出”）。
把元素添加到堆栈的顶端，使用 `append()` 。
从堆栈顶部取出元素，使用 `pop()` ，不用指定索引。例如：

```py
stack = []

stack.append(1)
stack.append(2)
stack.append(3)
stack.append(4)

print(stack.pop())
print(stack)
```

## 用列表实现队列

列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很低。
因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。

实现队列最好用 `collections.deque`，可以快速从两端添加或删除元素。例如：

```py
from collections import deque

queue = deque(["Eric", "John", "Michael"])

queue.append("Terry")
queue.append("Graham")

print(queue.popleft())
print(queue.popleft())

print(queue)
```

## 列表推导式

列表推导式创建列表的方式更简洁。
常见的用法为，对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。

```py
lists = []

for x in range(10):
    lists.append(x ** 2)

print(lists)
```

注意，这段代码创建（或覆盖）变量 x，该变量在循环结束后仍然存在。下述方法可以无副作用地计算平方列表：

```py
lists = [*map(lambda x: x ** 2, range(10))]
# same as
lists1 = list(map(lambda x: x ** 2, range(10)))

print(lists, lists1)
```

或等价于：

```py
squares = [x**2 for x in range(10)]
```

上面这种写法更简洁、易读。

列表推导式的方括号内包含以下内容：一个表达式，后面为一个 `for` 子句，然后，是零个或多个 `for` 或 `if` 子句。
结果是由表达式依据 `for` 和 `if` 子句求值计算而得出一个新列表。 
举例来说，以下列表推导式将两个列表中不相等的元素组合起来：

```py
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

## del 语句

`del` 语句按索引，而不是值从列表中移除元素。与返回值的 `pop()` 方法不同， `del` 语句也可以从列表中移除切片，
或清空整个列表（之前是将空列表赋值给切片）。 例如:

```py
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
print(a)

del a[2:4]
print(a)

del a[:]
print(a)
```

## 元组和序列

元组由多个用逗号隔开的值组成，例如：

```py
t = 12345, 54321, 'hello'

print(t[0])

print(t)

# Tuples may be nested
u = t, (1, 2, 3, 4, 5)

# # Tuples are immutable:
# t[0] = 888888888 #error
```

输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。
输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。
不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。

虽然，元组与列表很像，但使用场景不同，用途也不同。
元组是 `immutable` （不可变的），一般可包含异质元素序列，
通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访问）。
列表是 `mutable` （可变的），列表元素一般为同质类型，可迭代访问。

构造 `0` 个或 `1` 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。
用一对空圆括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只有一个值的话不够明确）。
丑陋，但是有效。例如：

```py
empty = ()
singleton = 'hello',    # <-- note trailing comma
len(empty)
0
len(singleton)
1
singleton
('hello',)
```

语句 `t = 12345, 54321, 'hello!'` 是 元组打包 的例子：值 `12345`, `54321` 和 `'hello!'` 一起被打包进元组。
逆操作也可以：

```py
x, y, z = t
```

称之为 序列解包 也是妥妥的，适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数量应相等。
注意，多重赋值其实只是元组打包和序列解包的组合。

## 集合

`Python` 还支持 **集合** 这种数据类型。
集合是由不重复元素组成的无序容器。
基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。

创建集合用花括号或 `set()` 函数。注意，创建空集合只能用 `set()`，不能用 `{}`，`{}` 创建的是空字典，
下一小节介绍数据结构：字典。

```py
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}

print(basket)
```

与 **列表推导式** 类似，集合也支持推导式：

```py
test_str = 'abracadabra'

a = {x for x in test_str if x not in 'abc'}
print(a)

a1 = set(filter(lambda x: x not in 'abc', test_str))
print(a1)
```

## 字典

字典也是一种常用的 `Python` 內置数据类型。
其他语言可能把字典称为 **联合内存** 或 **联合数组**。
与以连续整数为索引的序列不同，字典以 **关键字** 为索引，关键字通常是字符串或数字，也可以是其他任意不可变类型。
只包含字符串、数字、元组的元组，也可以用作关键字。
但如果元组直接或间接地包含了可变对象，就不能用作关键字。
列表不能当关键字，因为列表可以用索引、切片、`append()` 、`extend()` 等方法修改。

可以把字典理解为 **键值对** 的集合，但字典的键必须是唯一的。
花括号 `{}` 用于创建空字典。
另一种初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。

对字典执行 `list(d)` 操作，返回该字典中所有键的列表，按插入次序排列（如需排序，请使用 `sorted(d)`）。
检查字典里是否存在某个键，使用关键字 `in`。

