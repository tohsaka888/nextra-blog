# Input/Output 输入/输出设备

## 内存映射

![img](https://files.catbox.moe/on33v9.png)

Hack电脑还有两个外部设备：

- 显示器 Output输出设备，现实数据给用户
- 键盘 Input输入设备，获取用户输入数据

这两个设备和计算机平台的交互都是通过内存映射实现的。这意味着在屏幕上描绘像素是通过将二进制值写入屏幕相关的内存段来实现。
同样键盘的输入是通过读取与键盘相关的内存段来实现的。物理I/O设备和它们对应的内存映射是通过连续的循环刷新来实现的。

## 显示器

![img](https://files.catbox.moe/gfcv3b.png)

Hack计算机包括一个黑白屏幕，其中有`256 * 512`个像素点。屏幕的内容由RAM中基地址为`16384`的8K内存映射来实现。

> 采用8K大小的RAM的原因是：8K大小的RAM代表有`8*1024`也就是8192个`Register`，每一个`Register`可存储16位数据。
也就是说总共可存储`8 * 1024 * 16 = 131072`bit。而我们的屏幕有`256 * 512 = 131072`个像素点，这样刚好可以1bit控制
一个像素点，实现内存映射，`1`为黑，`0`为白。

物理屏幕的每一行用32位连续的16-位字（16bit）来表示。

> 32位的原因是：`32 * 16 = 512`

那么我们如何选取指定位置的像素用来读或写呢？

> 因为寄存器是16位的，所以每次读写都是16位同时操作，因而我们首先要找到当前需要修改的像素，是对应在8192个寄存器的
第几个寄存器当中的。

例如： 想要修改第`row`行，第`col`列的像素。

1. 首先找到这个像素是映射在第几个寄存器中 `32 * row + col / 16`
> $word = Screen[32 * row + col / 16]$ 这个公式指的是对应在`Screen`内存的第几个寄存器

> $word = RAM[16384 + 32 * row + col / 16]$ 这个公式指的是对应在整个RAM中的第几个寄存器，16384是`Screen`内存的基址
2. 找到是这个寄存器中的哪一位 `col % 16`
3. 把修改后的16位值，在写回找出的寄存器。

## 键盘  

![img](https://files.catbox.moe/prpo6l.png)
 
![img](https://files.catbox.moe/hegz9m.png)

Hack计算机和物理键盘之间通过RAM基地址位24576的单字节内存（一个Register）映射进行交互。只要在键盘上敲下一个按键，其对应的`ASCII`码值出现在`RAM[24576]`；
如果没有其敲击案件，该地址单元的值0。

![img](https://files.catbox.moe/6x8i78.png)