# Sequential Logic 时序逻辑

在前两章，所有的布尔芯片和算数芯片都是**组合芯片**(*combinational chip*)。组合芯片计算那些“输出结果仅依赖于输入变量的排列组合”的函数，
这些相关的简单芯片提供很多重要的处理功能（像ALU一样），但是它们却不能维持自身的状态。计算机不能要能计算值，还需要存取数据，因而这些芯片必须
配备**记忆单元**(*memory elements*)来保存数据，这些记忆单元是由**时序芯片**(*sequential chips*)组成。

## 背景

我们先来看一个例子：

我们需要处理一个累加，计算100个数（`a[100]`），如果我们使用组合芯片，大概的思路是：

- 通过Add Chip计算`a[0]`和`a[1]`的和s1
- 计算出s1和`a[2]`的和s2
- 计算出s2和`a[3]`的和s3
- ......
- 计算出s98和`a[99]`的和，输出

我们需要使用大量的芯片同步进行计算，并且经过这么多芯片的计算，计算机的执行效率也是非常低的。

如果我们可以记忆上一次的计算结果并且将这个结果作为下一次的输入，是不是只需要一块Add Chip就可以实现了呢？

## Clock 时钟

时钟（*Clock*），其精确的硬件实现通常基于振荡器，其在两个信号值0-1，或称“低电平-高电平”之间交替变化。每一个从0->1->0的过程看作一个周期。
而且我们把时钟的每个周期（一次上下波动）是为一个数字整数时间。通过硬件电路，这个信号同时呗传送到计算机平台的各个时序芯片中。

![img](https://files.catbox.moe/syd0ew.png)

以上图为例，我们通过一个`Not`门来进行观察：

- 在Time1时，输入是1，输出是0
- 在Time2时，输入是0，输出是1

## 组合芯片 VS 时序芯片

- combinational: $out[t] = function( in[t] )$
- sequential: $out[t] = function( in[t-1] )$

时序芯片也可以理解为：

- $state[t] = function( state[t-1] )$