# Machine Language Elements 机器语言组成元素

## 操作指令

机器语言的各种操作，实际上往往都对应着硬件的实现。

操作基本分三种：

- 算数操作：加、减、乘、除等
- 逻辑操作：与、或、非等
- 指令顺序控制：跳转、判断等

## 指令操作数据的方式

在说如何操作数据前，先说一下数据是如何在存储里读取的。

事实上访问这些存储时相当消耗资源的。需要提供一个长地址来对应存储（决于计算机体系结构和使用的地址总线的宽度，或者说计算机的位数）。
把存储的数据放入CPU也需要花费一定的时间。

为了解决访问速度和存储量扩大的冲突，需要把存储分层级来进行区分。

### 存储分级

首先是Register，通常在CPU内部，读取速度是最快的。

然后下一级是Cache，cache（缓存）是一种快速存储器，用于存储计算机处理器频繁使用的数据和指令。它的作用是提高计算机的运行速度，减少对主存储器的访问次数。

然后是主存储（*Main Memory*）存储大小比Cache大，速度相对于Cache就更慢了。其实，主存储其实就是电脑中的内存条。也就是我们
上一章实现的`RAM`。

最后是Disk，也就是电脑中的硬盘。

> 读取速度方面 Register > Cache > Main Memory/RAM > Disk

> 存储容量方面 Disk > Main Memory/RAM > Cache > Register

![img](https://files.catbox.moe/iiv9so.png)

### 寄存器

我们先深入了解一下寄存器：

寄存器主要分为两种：

- 数据寄存器（*Data Registers*）：存储的是数据，例如：`R1`、`R2`
- 地址寄存器（*Address Registers*）：存储的是其他寄存器的地址，例如：A

![img](https://files.catbox.moe/fmtdfp.png)

### 具体的操作方法

数据寄存器操作，例如：

```Hack
{/* R1 + R2 并将结果存储到R2 */}
Add R1,R2
```

直接寻址操作，例如：

```Hack
{/* R1 + 地址为200的寄存器里的数值，结果再存入200号寄存器 */}
Add R1,M[200]
```
地址寄存器间接寻址操作，例如：

```Hack
{/* R1 + 地址为地址存储器A中存储的地址的数据寄存器内的值，再存回A */}
Add R1, @A
```

立即数操作，例如：

```Hack
{/* 73 + R1,再存回R1 */} 
Add 73,R1
```
![img](https://files.catbox.moe/qym69n.png)

## 控制指令执行顺序

默认CPU是按照指令存储的顺序执行的。但有时需要特殊控制一下，例如：跳回前一步执行，以实现循坏之类的操作。

这里设计两种控制：

- 无条件跳转
- 有条件跳转

### 无条件跳转

无条件跳转 也是一个指令，例如：让`CPU`执行的下一步跳转（*Jump*）到第2行，那么命令就是`Jump Line2`，但我们
很难知道第二行命令的具体地址，所以为了简化方便，程序会提供一些功能来标识第二行的位置。例如下图的`loop`，这样我们
的命令就可以简化成`Jump loop`。

![img](https://files.catbox.moe/p80shb.png)

### 有条件跳转

`JGT`意为：`Jump Greater Than`。

例如：

```hack
{/* 如果R1>0，跳转到cont，否则顺序执行下一行 */}
JGT R1,0,cont
```

![img](https://files.catbox.moe/d52hhm.png)
